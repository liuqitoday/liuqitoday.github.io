<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuqitech</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://100067.xyz/"/>
  <updated>2023-03-30T02:21:15.125Z</updated>
  <id>https://100067.xyz/</id>
  
  <author>
    <name>liuqi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git filter-repo 简介</title>
    <link href="https://100067.xyz/2023/03/20/git-filter-repo/"/>
    <id>https://100067.xyz/2023/03/20/git-filter-repo/</id>
    <published>2023-03-19T16:00:00.000Z</published>
    <updated>2023-03-30T02:21:15.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>git filter-repo 是一个快速而灵活的工具，用于修改 Git 仓库的历史记录。</p><p>它可以用于许多任务，例如：</p><ul><li>重写提交历史记录</li><li>清理旧的大型文件</li><li>将仓库拆分成几个小仓库</li><li>将多个仓库合并成一个</li><li>移除密码和其他敏感数据</li></ul><p>Git-Filter-Repo的一些特性是：</p><ul><li>处理速度快</li><li>灵活，可配置性高</li><li>保留提交的作者和时间戳信息</li><li>可以对文件进行重命名和重构</li><li>可以对提交信息进行修改和删除</li><li>可以对提交信息进行搜索和替换</li><li>可以使用Python脚本进行自定义修改</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>MacOS 使用 homebrew 包管理工具进行安装，命令如下，其他方式参考官方文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git-filter-repo</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>假设我们有一个包含敏感文件的 Git 仓库，需要将这些文件从提交记录中移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-repo --path sensitive.txt --invert-paths</span><br></pre></td></tr></table></figure><p>这个命令会将所有包含 sensitive.txt 文件的提交从历史记录中移除。</p><a id="more"></a><h3 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h3><p>修改指定 commit 的 message 信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-filter-repo --message-callback &apos;return message.replace(b&quot;old commit message&quot;, b&quot;new commit message&quot;)&apos;</span><br></pre></td></tr></table></figure><p>其中，<code>new commit message</code> 是你想要修改的新 commit message，<code>old commit message</code> 是你想要修改的旧 commit message。</p><h3 id="替换指定的字符串"><a href="#替换指定的字符串" class="headerlink" title="替换指定的字符串"></a>替换指定的字符串</h3><p>例如我们的项目中，存在密码等敏感信息，我们希望将敏感信息删除。</p><p>首先我们需要创建文件，按照如下格式将替换文本的相关内容填写其中，如文件名为 expressions</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password123==&gt;******</span><br></pre></td></tr></table></figure><p>以上内容表示，将 <code>password123</code>替换为 <code>******</code>，执行下面的命令进行替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-repo --replace-text ../expressions</span><br></pre></td></tr></table></figure><h3 id="修改-commit-信息中的-user-与-mail"><a href="#修改-commit-信息中的-user-与-mail" class="headerlink" title="修改 commit 信息中的 user 与 mail"></a>修改 commit 信息中的 user 与 mail</h3><p>新建 mailmap 文件，如文件名为 my-mailmap，文件内容格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liuqitoday &lt;liuqitoday@163.com&gt; liuqitech &lt;liuqitech@email.com&gt;</span><br></pre></td></tr></table></figure><p>执行下面的命令便会帮我们批量将commit 历史中的作者信息 <code>liuqitech &lt;liuqitech@email.com</code>&gt;  替换为 <code>liuqitech &lt;liuqitech@email.com&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-repo --mailmap ../my-mailmap</span><br></pre></td></tr></table></figure><h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><p>如将 README.md 重命名为 README_1.md</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-repo --path-rename README.md:README_1.md</span><br></pre></td></tr></table></figure><h3 id="提取子目录"><a href="#提取子目录" class="headerlink" title="提取子目录"></a>提取子目录</h3><p>有时候，我们只需要一个 Git 仓库中的某个子目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-repo --path path/to/subdir</span><br></pre></td></tr></table></figure><p>这个命令将会把 <code>path/to/subdir</code> 目录提取出来，形成一个新的 Git 仓库。</p><h3 id="提取子目录下的所有文件"><a href="#提取子目录下的所有文件" class="headerlink" title="提取子目录下的所有文件"></a>提取子目录下的所有文件</h3><p>如将 <code>path/to/subdir</code> 目录下的所有文件调整到根目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-repo --subdirectory-filter path/to/subdir</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;git filter-repo 是一个快速而灵活的工具，用于修改 Git 仓库的历史记录。&lt;/p&gt;
&lt;p&gt;它可以用于许多任务，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重写提交历史记录&lt;/li&gt;
&lt;li&gt;清理旧的大型文件&lt;/li&gt;
&lt;li&gt;将仓库拆分成几个小仓库&lt;/li&gt;
&lt;li&gt;将多个仓库合并成一个&lt;/li&gt;
&lt;li&gt;移除密码和其他敏感数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git-Filter-Repo的一些特性是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理速度快&lt;/li&gt;
&lt;li&gt;灵活，可配置性高&lt;/li&gt;
&lt;li&gt;保留提交的作者和时间戳信息&lt;/li&gt;
&lt;li&gt;可以对文件进行重命名和重构&lt;/li&gt;
&lt;li&gt;可以对提交信息进行修改和删除&lt;/li&gt;
&lt;li&gt;可以对提交信息进行搜索和替换&lt;/li&gt;
&lt;li&gt;可以使用Python脚本进行自定义修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;MacOS 使用 homebrew 包管理工具进行安装，命令如下，其他方式参考官方文档&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew install git-filter-repo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;使用示例&quot;&gt;&lt;a href=&quot;#使用示例&quot; class=&quot;headerlink&quot; title=&quot;使用示例&quot;&gt;&lt;/a&gt;使用示例&lt;/h2&gt;&lt;h3 id=&quot;移除文件&quot;&gt;&lt;a href=&quot;#移除文件&quot; class=&quot;headerlink&quot; title=&quot;移除文件&quot;&gt;&lt;/a&gt;移除文件&lt;/h3&gt;&lt;p&gt;假设我们有一个包含敏感文件的 Git 仓库，需要将这些文件从提交记录中移除。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git filter-repo --path sensitive.txt --invert-paths&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这个命令会将所有包含 sensitive.txt 文件的提交从历史记录中移除。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://100067.xyz/categories/Git/"/>
    
    
      <category term="Git" scheme="https://100067.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Google Pixel (Android 10) 安装 Magisk 过程记录</title>
    <link href="https://100067.xyz/2021/08/22/google_pixel_android_10_install_magisk/"/>
    <id>https://100067.xyz/2021/08/22/google_pixel_android_10_install_magisk/</id>
    <published>2021-08-21T16:20:00.000Z</published>
    <updated>2021-08-22T05:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mac-安装-android-platform-tools"><a href="#Mac-安装-android-platform-tools" class="headerlink" title="Mac 安装 android-platform-tools"></a>Mac 安装 android-platform-tools</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask android-platform-tools</span><br></pre></td></tr></table></figure><h3 id="解锁-bootloader"><a href="#解锁-bootloader" class="headerlink" title="解锁 bootloader"></a>解锁 bootloader</h3><p>手机进入开发者模式 打开 USB调试模式，并勾选 ”OEM解锁“</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flashing unlock</span><br></pre></td></tr></table></figure><h3 id="提取原版-boot-img"><a href="#提取原版-boot-img" class="headerlink" title="提取原版 boot.img"></a>提取原版 boot.img</h3><p>下载<a href="https://developers.google.com/android/images#flashtool" target="_blank" rel="noopener">原版刷机包</a>并提取 boot.img 文件</p><h3 id="制作-Magisk-patch"><a href="#制作-Magisk-patch" class="headerlink" title="制作 Magisk patch"></a>制作 Magisk patch</h3><p>下载 <a href="https://github.com/topjohnwu/Magisk/releases" target="_blank" rel="noopener">Magisk</a> 安装文件，把 Magisk安装文件以及上一步中提取的 boot.img 传入手机中 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push Magisk-v23.0.apk /sdcard/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push boot.img /sdcard/</span><br></pre></td></tr></table></figure><p>手机端安装并打开 Magisk 应用，Magisk - 安装 - 选择并修补一个文件，选择 boot.img 文件，点开始按钮开始制作补丁，制作完毕后查看日志中生成的 magisk_patched.img 文件路径，将文件拷贝到电脑中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/Download/magisk_patched.img ~/Downloads/</span><br></pre></td></tr></table></figure><h3 id="刷写-magisk-patched-img"><a href="#刷写-magisk-patched-img" class="headerlink" title="刷写 magisk_patched.img"></a>刷写 magisk_patched.img</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot fastboot</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash boot magisk_patched.img</span><br></pre></td></tr></table></figure><h3 id="重启并验证"><a href="#重启并验证" class="headerlink" title="重启并验证"></a>重启并验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><p>打开 Magisk APP 显示各种状态均正常，成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mac-安装-android-platform-tools&quot;&gt;&lt;a href=&quot;#Mac-安装-android-platform-tools&quot; class=&quot;headerlink&quot; title=&quot;Mac 安装 android-platform-tools&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Android" scheme="https://100067.xyz/categories/Android/"/>
    
    
      <category term="Android" scheme="https://100067.xyz/tags/Android/"/>
    
      <category term="Magisk" scheme="https://100067.xyz/tags/Magisk/"/>
    
  </entry>
  
  <entry>
    <title>iPhone 照片同步至 Pixel</title>
    <link href="https://100067.xyz/2021/08/21/photos_sync_to_pixel/"/>
    <id>https://100067.xyz/2021/08/21/photos_sync_to_pixel/</id>
    <published>2021-08-21T07:00:00.000Z</published>
    <updated>2022-05-02T10:24:59.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-Synology-Photos"><a href="#安装-Synology-Photos" class="headerlink" title="安装 Synology Photos"></a>安装 Synology Photos</h2><p>群晖安装<code>Synology Photos</code> 套件，iPhone 手机端安装 <code>Photos Mobile</code> APP，使用该 APP 对手机照片进行备份。</p><h2 id="安装-Syncthing"><a href="#安装-Syncthing" class="headerlink" title="安装 Syncthing"></a>安装 Syncthing</h2><p>群晖添加社区套件源 <code>https://packages.synocommunity.com/</code>，并安装 <code>Syncthing</code>  套件。Pixel 手机端安装 <code>Syncthing</code>  APP。</p><h2 id="配置-Syncthing"><a href="#配置-Syncthing" class="headerlink" title="配置 Syncthing"></a>配置 Syncthing</h2><ol><li>照片目录权限配置。群晖端使用 File Station，将照片所在目录（例如 homes/liuqi/Photos/MobileBackup）的读写权限设置给 sc-syncthing 用户。</li><li>添加设备。群晖端 Syncthing 显示设备二维码（操作 - 显示ID），手机端操作“添加设备”并扫描该二维码完成添加，此时在群晖的端 Syncthing 页面同意添加进来的设备。</li><li>群晖端 Syncthing 配置同步文件夹。群晖端 Syncthing 添加文件夹，常规标签页面下，填写文件夹标签（例如 tag_dsm_photos_lq）、文件夹ID（例如 id_dsm_photos_lq）、文件夹路径（例如 /var/services/homes/liuqi/Photos/MobileBackup）等信息。共享标签页面下勾选上一步添加的 Pixel 手机。忽略模式标签页面下添加@eaDir。高级标签页面下文件夹类型修改为仅发送，勾选忽略文件权限。进行保存。</li><li>Pixel 手机端 Syncthing 配置同步文件夹。此时打开 Pixel 手机端 Syncthing APP，同意提示添加的同步文件夹信息，并配置手机端的文件夹目录，目录种类修改为仅接收。 </li><li>查看两端的 Syncthing 显示的同步进度是否正常，完成。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-Synology-Photos&quot;&gt;&lt;a href=&quot;#安装-Synology-Photos&quot; class=&quot;headerlink&quot; title=&quot;安装 Synology Photos&quot;&gt;&lt;/a&gt;安装 Synology Photos&lt;/h2&gt;&lt;p&gt;群晖安装&lt;c
      
    
    </summary>
    
      <category term="Synology" scheme="https://100067.xyz/categories/Synology/"/>
    
    
      <category term="Android" scheme="https://100067.xyz/tags/Android/"/>
    
      <category term="DSM" scheme="https://100067.xyz/tags/DSM/"/>
    
      <category term="Synology" scheme="https://100067.xyz/tags/Synology/"/>
    
      <category term="群晖" scheme="https://100067.xyz/tags/%E7%BE%A4%E6%99%96/"/>
    
      <category term="Pixel" scheme="https://100067.xyz/tags/Pixel/"/>
    
      <category term="iPhone" scheme="https://100067.xyz/tags/iPhone/"/>
    
  </entry>
  
  <entry>
    <title>Spring DeferredResult 指南（译）</title>
    <link href="https://100067.xyz/2021/02/07/spring-deferred-result/"/>
    <id>https://100067.xyz/2021/02/07/spring-deferred-result/</id>
    <published>2021-02-07T07:00:00.000Z</published>
    <updated>2021-02-07T08:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在本教程中，我们将研究如何在<code>Spring MVC</code>使用 <em>DeferredResult</em> 类来执行异步请求处理。</p><p><code>Selvet 3.0</code>中已经引入了异步的支持，简单来说，它允许在请求接收器线程外的另一个线程中去处理该HTTP请求。</p><p>从<code>Spring 3.2</code>起，就可以使用<em>DeferredResult</em>，它帮助我们将长时间的计算过程从<code>http-worker</code>线程中分离到一个单独的线程中。</p><p>尽管其他线程将占用一些资源用于计算，但工作线程在此期间不会阻塞，仍然可以继续处理传入的客户端请求。</p><p>异步请求处理模型非常有用，因为它有助于在高负载时很好地扩展应用程序，特别是对于IO密集型操作。</p><a id="more"></a><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><p>我们将使用一个 Spring Boot 应用作为例子。然后，我们将展示同步通信和使用<em>DeferredResult</em> 的异步通信，并使用例子比较异步是如何更好地适应高负载和IO密集型。</p><h2 id="3-阻塞的-REST-服务"><a href="#3-阻塞的-REST-服务" class="headerlink" title="3. 阻塞的 REST 服务"></a>3. 阻塞的 REST 服务</h2><p>我们以一个标准的阻塞的 REST 服务开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/process-blocking&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; handleReqSync() &#123;</span><br><span class="line">    // ...</span><br><span class="line">    return ResponseEntity.ok(&quot;ok&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的问题是，请求处理线程在处理完成返回结果前是一直被阻塞的，对于需要进行长时间的计算时这不是一个好的解决方案。</p><h2 id="4-使用-DeferredResult-非阻塞的-REST-服务"><a href="#4-使用-DeferredResult-非阻塞的-REST-服务" class="headerlink" title="4. 使用 DeferredResult 非阻塞的 REST 服务"></a>4. 使用 <em>DeferredResult</em> 非阻塞的 REST 服务</h2><p>为了避免阻塞，我们将使用基于回调的模型，我们将返回一个 <em>DeferredResult</em> 到 Servlet 容器中，来取代实际的返回结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/async-deferredresult&quot;)</span><br><span class="line">public DeferredResult&lt;ResponseEntity&lt;?&gt;&gt; handleReqDefResult() &#123;</span><br><span class="line">    log.info(&quot;Received async-deferredresult request&quot;);</span><br><span class="line">    DeferredResult&lt;ResponseEntity&lt;?&gt;&gt; output = new DeferredResult&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ForkJoinPool.commonPool().submit(() -&gt; &#123;</span><br><span class="line">        log.info(&quot;Processing in separate thread&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(6000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        output.setResult(ResponseEntity.ok(&quot;ok&quot;));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    log.info(&quot;servlet thread freed&quot;);</span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求的处理逻辑在一个单独的线程中完成，并且完成之后调用  <em>DeferredResult</em> 类的 <em>setResult</em> 方法来设置实际结果。</p><p>下面是日志输出结果，看看是否按照我们的预期顺序输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Received async-deferredresult request</span><br><span class="line">servlet thread freed</span><br><span class="line">Processing in separate thread</span><br></pre></td></tr></table></figure><p>在内部，将通知容器线程并将 HTTP 响应返回给给客户端。连接将由容器(servlet 3.0或更高版本)一直保持打开的状态，直到返回相应结果或超时。</p><h2 id="5-DeferredResult-回调"><a href="#5-DeferredResult-回调" class="headerlink" title="5. DeferredResult 回调"></a>5. <em>DeferredResult</em> 回调</h2><p>我们可以使用<em>DeferredResult</em> 注册3种类型的回调：完成、超时与异常。</p><p>我们使用<code>onCompletion</code> 方法来定义一个异步请求完成时执行的代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferredResult.onCompletion(() -&gt; log.info(&quot;Processing complete&quot;));</span><br></pre></td></tr></table></figure><p>为了限制请求的处理时间，我们可以在 <em>DeferredResult</em> 实例化时设置一个超时时间，并且可以使用<code>ontTimeout</code> 方法来注册一个自定义的代码块用来在超时后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DeferredResult&lt;ResponseEntity&lt;?&gt;&gt; deferredResult = new DeferredResult&lt;&gt;(500L);</span><br><span class="line"></span><br><span class="line">deferredResult.onTimeout(() -&gt;</span><br><span class="line">        deferredResult.setErrorResult(</span><br><span class="line">                ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT)</span><br><span class="line">                        .body(&quot;Request timeout occurred.&quot;)));</span><br></pre></td></tr></table></figure><p>我们还可以使用<code>onError</code> 方法来注册一个发生异常时的回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deferredResult.onError((Throwable t) -&gt; &#123;</span><br><span class="line">    deferredResult.setErrorResult(</span><br><span class="line">      ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">        .body(&quot;An error occurred.&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://www.baeldung.com/spring-deferred-result" target="_blank" rel="noopener">https://www.baeldung.com/spring-deferred-result</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在本教程中，我们将研究如何在&lt;code&gt;Spring MVC&lt;/code&gt;使用 &lt;em&gt;DeferredResult&lt;/em&gt; 类来执行异步请求处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Selvet 3.0&lt;/code&gt;中已经引入了异步的支持，简单来说，它允许在请求接收器线程外的另一个线程中去处理该HTTP请求。&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;Spring 3.2&lt;/code&gt;起，就可以使用&lt;em&gt;DeferredResult&lt;/em&gt;，它帮助我们将长时间的计算过程从&lt;code&gt;http-worker&lt;/code&gt;线程中分离到一个单独的线程中。&lt;/p&gt;
&lt;p&gt;尽管其他线程将占用一些资源用于计算，但工作线程在此期间不会阻塞，仍然可以继续处理传入的客户端请求。&lt;/p&gt;
&lt;p&gt;异步请求处理模型非常有用，因为它有助于在高负载时很好地扩展应用程序，特别是对于IO密集型操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://100067.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="https://100067.xyz/tags/Java/"/>
    
      <category term="Spring" scheme="https://100067.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>数组实现队列</title>
    <link href="https://100067.xyz/2020/11/03/array-implementation-of-queue/"/>
    <id>https://100067.xyz/2020/11/03/array-implementation-of-queue/</id>
    <published>2020-11-03T10:00:00.000Z</published>
    <updated>2021-01-14T10:38:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>队列</strong>，又称为<strong>伫列</strong>（queue），<a href="https://zh.wikipedia.org/wiki/計算機科學" target="_blank" rel="noopener">计算机科学</a>中的一种<a href="https://zh.wikipedia.org/wiki/抽象資料型別" target="_blank" rel="noopener">抽象资料型别</a>，是<a href="https://zh.wikipedia.org/wiki/先進先出演算法" target="_blank" rel="noopener">先进先出</a>（FIFO, First-In-First-Out）的<a href="https://zh.wikipedia.org/wiki/线性表" target="_blank" rel="noopener">线性表</a>。在具体应用中通常用<a href="https://zh.wikipedia.org/wiki/链表" target="_blank" rel="noopener">链表</a>或者<a href="https://zh.wikipedia.org/wiki/数组" target="_blank" rel="noopener">数组</a>来实现。队列只允许在后端（称为<em>rear</em>）进行插入操作，在前端（称为<em>front</em>）进行删除操作。</p><p>从上述的概念中我们可得知，<strong>队列</strong>两个主要的操作为<strong>入队</strong>(enqueue)与<strong>出队</strong>(dequeue)，入队为从队尾插入元素，出队为从队首去删除元素。</p><h3 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h3><p>数组实现的队列即元素容器为数组，为了完成入队与出队列的操作，同时还需要两个指针来标记队首和队尾。</p>  <a id="more"></a><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayQueueTest &#123;</span><br><span class="line"></span><br><span class="line">    private final int[] items;</span><br><span class="line">    /**</span><br><span class="line">     * front 队首指针</span><br><span class="line">     * rear 对尾指针</span><br><span class="line">     * capital 队列容量</span><br><span class="line">     */</span><br><span class="line">    private int front, rear, capital;</span><br><span class="line"></span><br><span class="line">    public ArrayQueueTest(Integer capital) &#123;</span><br><span class="line">        this.items = new int[capital];</span><br><span class="line">        this.capital = capital;</span><br><span class="line">        this.front = rear = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从队尾插入元素</span><br><span class="line">     *</span><br><span class="line">     * @param item 元素</span><br><span class="line">     */</span><br><span class="line">    public void add(int item) &#123;</span><br><span class="line">        // 当前容量已满</span><br><span class="line">        if (rear == capital) &#123;</span><br><span class="line">            if (front == 0) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;队列已满&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 所有元素向前移动一位</span><br><span class="line">                for (int i = 0; i &lt; items.length - 1; i++) &#123;</span><br><span class="line">                    items[i] = items[i + 1];</span><br><span class="line">                &#125;</span><br><span class="line">                // 队尾指针向前移动一位，同时队首指针向前移动一位</span><br><span class="line">                rear--;</span><br><span class="line">                front--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        items[rear] = item;</span><br><span class="line">        rear++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从队首取出元素</span><br><span class="line">     *</span><br><span class="line">     * @return 队首取出的元素</span><br><span class="line">     */</span><br><span class="line">    public int remove() &#123;</span><br><span class="line">        if (front == capital) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int item = items[front];</span><br><span class="line">        front++;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取队列所有元素</span><br><span class="line">     *</span><br><span class="line">     * @return 队列所有元素数组</span><br><span class="line">     */</span><br><span class="line">    public int[] getItems() &#123;</span><br><span class="line">        int[] outItems = new int[rear - front];</span><br><span class="line">        for (int i = 0; i &lt; outItems.length; i++) &#123;</span><br><span class="line">            outItems[i] = items[front + i];</span><br><span class="line">        &#125;</span><br><span class="line">        return outItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayQueueTest arrayQueue = new ArrayQueueTest(5);</span><br><span class="line">        arrayQueue.add(1);</span><br><span class="line">        arrayQueue.add(2);</span><br><span class="line">        arrayQueue.add(3);</span><br><span class="line">        arrayQueue.add(4);</span><br><span class="line">        arrayQueue.add(5);</span><br><span class="line">        System.out.println(Arrays.toString(arrayQueue.getItems()));</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            int removeItem = arrayQueue.remove();</span><br><span class="line">            System.out.println(removeItem);</span><br><span class="line">            System.out.println(Arrays.toString(arrayQueue.getItems()));</span><br><span class="line">        &#125;</span><br><span class="line">        arrayQueue.add(8);</span><br><span class="line">        System.out.println(Arrays.toString(arrayQueue.getItems()));</span><br><span class="line">        arrayQueue.add(9);</span><br><span class="line">        System.out.println(Arrays.toString(arrayQueue.getItems()));</span><br><span class="line"></span><br><span class="line">//        for (int i = 10; i &lt; 20; i++) &#123;</span><br><span class="line">//            arrayQueue.add(i);</span><br><span class="line">//            System.out.println(Arrays.toString(arrayQueue.getItems()));</span><br><span class="line">//        &#125;</span><br><span class="line">//        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">//            System.out.println(arrayQueue.remove());</span><br><span class="line">//            System.out.println(Arrays.toString(arrayQueue.getItems()));</span><br><span class="line">//        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;队列&lt;/strong&gt;，又称为&lt;strong&gt;伫列&lt;/strong&gt;（queue），&lt;a href=&quot;https://zh.wikipedia.org/wiki/計算機科學&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机科学&lt;/a&gt;中的一种&lt;a href=&quot;https://zh.wikipedia.org/wiki/抽象資料型別&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;抽象资料型别&lt;/a&gt;，是&lt;a href=&quot;https://zh.wikipedia.org/wiki/先進先出演算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;先进先出&lt;/a&gt;（FIFO, First-In-First-Out）的&lt;a href=&quot;https://zh.wikipedia.org/wiki/线性表&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线性表&lt;/a&gt;。在具体应用中通常用&lt;a href=&quot;https://zh.wikipedia.org/wiki/链表&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链表&lt;/a&gt;或者&lt;a href=&quot;https://zh.wikipedia.org/wiki/数组&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组&lt;/a&gt;来实现。队列只允许在后端（称为&lt;em&gt;rear&lt;/em&gt;）进行插入操作，在前端（称为&lt;em&gt;front&lt;/em&gt;）进行删除操作。&lt;/p&gt;
&lt;p&gt;从上述的概念中我们可得知，&lt;strong&gt;队列&lt;/strong&gt;两个主要的操作为&lt;strong&gt;入队&lt;/strong&gt;(enqueue)与&lt;strong&gt;出队&lt;/strong&gt;(dequeue)，入队为从队尾插入元素，出队为从队首去删除元素。&lt;/p&gt;
&lt;h3 id=&quot;数组实现队列&quot;&gt;&lt;a href=&quot;#数组实现队列&quot; class=&quot;headerlink&quot; title=&quot;数组实现队列&quot;&gt;&lt;/a&gt;数组实现队列&lt;/h3&gt;&lt;p&gt;数组实现的队列即元素容器为数组，为了完成入队与出队列的操作，同时还需要两个指针来标记队首和队尾。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://100067.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="https://100067.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用Keepalived实现简单的Nginx高可用</title>
    <link href="https://100067.xyz/2020/02/28/nginx_keepalived/"/>
    <id>https://100067.xyz/2020/02/28/nginx_keepalived/</id>
    <published>2020-02-28T10:00:00.000Z</published>
    <updated>2020-03-17T10:26:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h4><p>Nginx Master : 192.168.123.101</p><p>Nginx Backup : 192.168.123.102</p><p>VIP : 192.168.123.103</p><h4 id="安装Keepalived"><a href="#安装Keepalived" class="headerlink" title="安装Keepalived"></a>安装Keepalived</h4><p>以上两台Nginx所在的机器分别安装Keepalived</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install keepalived</span><br></pre></td></tr></table></figure><h4 id="配置Keepalived"><a href="#配置Keepalived" class="headerlink" title="配置Keepalived"></a>配置Keepalived</h4><p>修改 nginx master 所在机器的keepalived 的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/keepalived/keepalived.conf</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">       admin@liuqitech.com.com     #设置报警邮件地址，可以设置多个，每行一个。 需开启本机的sendmail服务</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from no-reply@liuqitech.com  #设置邮件的发送地址</span><br><span class="line">   smtp_server 127.0.0.1      #设置smtp server地址</span><br><span class="line">   smtp_connect_timeout 30    #设置连接smtp server的超时时间</span><br><span class="line">   router_id LVS_DEVEL_1              #表示运行keepalived服务器的一个标识。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">    script &quot;/usr/local/keepalived/sbin/check_nginx.sh&quot;   #该脚本检测ngnix的运行状态，并在nginx进程不存在时尝 试重新启动ngnix，如果启动失败则停止keepalived，准备让其它机器接管。</span><br><span class="line">    interval 2              #每2s检测一次</span><br><span class="line">    weight -20               #检测失败则优先级-20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER              #指定keepalived的角色，MASTER表示此主机是主服务器，BACKUP表示此主机是备用服务器</span><br><span class="line">    interface eth0              #指定HA监测网络的接口 可通过ifconfig查看</span><br><span class="line">    virtual_router_id 55    #虚拟路由标识，这个标识是一个数字，同一个vrrp实例使用唯一的标识。即同一vrrp_instance下，MASTER和BACKUP必须是一致的</span><br><span class="line">    priority 100                  #定义优先级，数字越大，优先级越高，在同一个vrrp_instance下，MASTER的优先级必须大于BACKUP的优先级</span><br><span class="line">    advert_int 1            #设定MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒</span><br><span class="line">    authentication &#123;        #设置验证类型和密码</span><br><span class="line">        auth_type PASS      #设置验证类型，主要有PASS和AH两种</span><br><span class="line">        auth_pass liuqitech  #设置验证密码，在同一个vrrp_instance下，MASTER与BACKUP必须使用相同的密码才能正常通信</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;     #设置虚拟IP地址，可以设置多个虚拟IP地址，每行一个</span><br><span class="line">        192.168.123.103</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx           #引用VRRP脚本，即在 vrrp_script 部分指定的名字。定期运行它们来改变优先级，并最终引发主备切换。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 nginx backup 所在机器的keepalived的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">       admin@liuqitech.com     #设置报警邮件地址，可以设置多个，每行一个。 需开启本机的sendmail服务</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from no-reply@liuqitech.com  #设置邮件的发送地址</span><br><span class="line">   smtp_server 127.0.0.1      #设置smtp server地址</span><br><span class="line">   smtp_connect_timeout 30    #设置连接smtp server的超时时间</span><br><span class="line">   router_id LVS_DEVEL_2        #表示运行keepalived服务器的一个标识。发邮件时显示在邮件主题的信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">    script &quot;/usr /local/keepalived/sbin/check_nginx.sh&quot;   #该脚本检测ngnix的运行状态，并在nginx进程不存在时尝 试重新启动ngnix，如果启动失败则停止keepalived，准备让其它机器接管。</span><br><span class="line">    interval 2              #每2s检测一次</span><br><span class="line">    weight -20                #检测失败则优先级-20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP            #指定keepalived的角色，MASTER表示此主机是主服务器，BACKUP表示此主机是备用服务器</span><br><span class="line">    interface eth0          #指定HA监测网络的接口</span><br><span class="line">    virtual_router_id 55    #虚拟路由标识，这个标识是一个数字，同一个vrrp实例使用唯一的标识。即同一vrrp_instance下，MASTER和BACKUP必须是一致的</span><br><span class="line">    priority 50             #定义优先级，数字越大，优先级越高，在同一个vrrp_instance下，MASTER的优先级必须大于BACKUP的优先级</span><br><span class="line">    advert_int 1            #设定MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒</span><br><span class="line">    nopreempt               #设置nopreempt防止抢占资源，只生效BACKUP节点</span><br><span class="line">    authentication &#123;        #设置验证类型和密码</span><br><span class="line">        auth_type PASS      #设置验证类型，主要有PASS和AH两种</span><br><span class="line">        auth_pass liuqitech  #设置验证密码，在同一个vrrp_instance下，MASTER与BACKUP必须使用相同的密码才能正常通信</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;     #设置虚拟IP地址，可以设置多个虚拟IP地址，每行一个</span><br><span class="line">        192.168.123.103</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx           #引用VRRP脚本，即在 vrrp_script 部分指定的名字。定期运行它们来改变优先级，并最终引发主备切换。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测脚本，vi /usr/local/keepalived/sbin/check_nginx.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">A=`ps -C nginx --no-header |wc -l`</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    sleep 2</span><br><span class="line">    /user/local/nginx/sbin/nginx</span><br><span class="line">    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>脚本说明：此方法比较暴力，若没有到nginx进程并且重启后仍检测不到，则kill掉keepalived</p><p>脚本加上可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/keepalived/sbin/check_nginx.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                                                                 </span><br><span class="line">                                      +----------+               </span><br><span class="line">                  +----------+        |  Tomcat  |               </span><br><span class="line">                  |  Nginx   |        +----------+               </span><br><span class="line">                  +----------+                                   </span><br><span class="line">+----------+                          +----------+               </span><br><span class="line">|  虚拟IP   |                          |  Tomcat  |               </span><br><span class="line">+----------+                          +----------+               </span><br><span class="line">                  +----------+                                   </span><br><span class="line">                  |  Nginx   |        +----------+               </span><br><span class="line">                  +----------+        |  Tomcat  |               </span><br><span class="line">                                      +----------+</span><br></pre></td></tr></table></figure><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.linuxprobe.com/keepalived-nginx.html" target="_blank" rel="noopener">https://www.linuxprobe.com/keepalived-nginx.html</a></p><p><a href="https://www.centos.bz/2017/09/nginx-keepalived-高可用/" target="_blank" rel="noopener">https://www.centos.bz/2017/09/nginx-keepalived-%E9%AB%98%E5%8F%AF%E7%94%A8/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;环境说明&quot;&gt;&lt;a href=&quot;#环境说明&quot; class=&quot;headerlink&quot; title=&quot;环境说明&quot;&gt;&lt;/a&gt;环境说明&lt;/h4&gt;&lt;p&gt;Nginx Master : 192.168.123.101&lt;/p&gt;
&lt;p&gt;Nginx Backup : 192.168.123.102&lt;/p&gt;
&lt;p&gt;VIP : 192.168.123.103&lt;/p&gt;
&lt;h4 id=&quot;安装Keepalived&quot;&gt;&lt;a href=&quot;#安装Keepalived&quot; class=&quot;headerlink&quot; title=&quot;安装Keepalived&quot;&gt;&lt;/a&gt;安装Keepalived&lt;/h4&gt;&lt;p&gt;以上两台Nginx所在的机器分别安装Keepalived&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install keepalived&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;配置Keepalived&quot;&gt;&lt;a href=&quot;#配置Keepalived&quot; class=&quot;headerlink&quot; title=&quot;配置Keepalived&quot;&gt;&lt;/a&gt;配置Keepalived&lt;/h4&gt;&lt;p&gt;修改 nginx master 所在机器的keepalived 的配置文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vi /etc/keepalived/keepalived.conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://100067.xyz/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://100067.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Replication 主从复制 配置</title>
    <link href="https://100067.xyz/2020/02/27/mysql_replication/"/>
    <id>https://100067.xyz/2020/02/27/mysql_replication/</id>
    <published>2020-02-27T08:00:00.000Z</published>
    <updated>2020-03-07T10:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><em>Replication</em> 可以使数据从一个MySQL数据库(master)复制到一个或多个MySQL数据库(slave)中，默认情况下该复制过程是异步的。我们可以通过配置来实现复制所有的<em>database</em>或者指定的<em>database</em>。</p><p>MySQL Replication 的优点如下：</p><ul><li>横向扩展：可以将负载分布在多个slave上以提高性能。所有的写操作都必须在master上进行，但是读操作可以分布在一个或多个slave上。这样的模型可以提高写入性能，因为master专注于数据更新，同时多个slave可以显著的提高读取速度。</li><li>数据安全：定期备份是保护数据的重要手段之一，若在master上进行数据备份则需要使master处于readonly状态，这将影响写操作 。而salve可以暂停复制的过程，所以slave上进行数据备份而不会影响到master。</li><li>分析：数据是从master上实时写入的，数据分析可以在slave上进行而不影响master的性能。</li><li>远程数据分发：如果master的物理位置距离较远，我们可以在临近的地方创建slave，方便使用数据使用，而不需要总是访问远端的master。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>作为master 的MySQL实例将数据的变更操作作为”事件”记录到<code>binary log</code>中，slave 的MySQL实例被被指为读取master的<code>binary log</code>，slave将读取到的<code>binary log</code>写入自己的中继日志中，然后slave回把相关的事件进行执行。slave具体执行哪些事件由slave决定。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="创建用于复制的账号"><a href="#创建用于复制的账号" class="headerlink" title="创建用于复制的账号"></a>创建用于复制的账号</h5><p>进入master的MySQL实例，执行以下操作：</p><p>执行以下命令创建账号，其中<code>172.20.254.176</code>为slave的MySQL的ip，<code>liuqitech@2020</code>为密码。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &apos;slave&apos;@&apos;172.20.254.176&apos; IDENTIFIED BY &apos;liuqitech@2020&apos;;</span><br></pre></td></tr></table></figure><p>分配权限，其中<code>replication slave</code> 表示 主从复制权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &apos;slave&apos;@&apos;172.20.254.176&apos;;</span><br></pre></td></tr></table></figure><p>刷新权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h5 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h5><p>开启二进制日志并设置唯一的server-id。修改<code>my.cnf</code>，添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin #表示开启binlog，并且指定二进制日志文件名为mysql-bin</span><br><span class="line">server-id=1 #唯一的服务ID</span><br></pre></td></tr></table></figure><p>重启MySQL使之生效</p><h5 id="slave配置"><a href="#slave配置" class="headerlink" title="slave配置"></a>slave配置</h5><p>被指唯一的server-id。修改<code>my.cnf</code>，添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure><p>重启MySQL使之生效</p><h5 id="获取master的二进制日志文件坐标"><a href="#获取master的二进制日志文件坐标" class="headerlink" title="获取master的二进制日志文件坐标"></a>获取master的二进制日志文件坐标</h5><p>master上执行以下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; SHOW MASTER STATUS;</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br><span class="line">| mysql-bin.000001 | 67       |              |                  |</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br></pre></td></tr></table></figure><p>记录File、Position的值</p><h5 id="连接slave到master"><a href="#连接slave到master" class="headerlink" title="连接slave到master"></a>连接slave到master</h5><p>slave上执行以下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">         MASTER_HOST=&apos;172.20.254.175&apos;,</span><br><span class="line">         MASTER_USER=&apos;slave&apos;,</span><br><span class="line">         MASTER_PASSWORD=&apos;liuqitech@2020&apos;,</span><br><span class="line">         MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;,</span><br><span class="line">         MASTER_LOG_POS=67;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure><h5 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h5><p>slave 中执行 查看状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW SLAVE STATUS \G</span><br></pre></td></tr></table></figure><p>观察是否正常运行中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;&lt;em&gt;Replication&lt;/em&gt; 可以使数据从一个MySQL数据库(master)复制到一个或多个MySQL数据库(slave)中，默认情况下该复制过程是异步的。我们可以通过配置来实现复制所有的&lt;em&gt;database&lt;/em&gt;或者指定的&lt;em&gt;database&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;MySQL Replication 的优点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;横向扩展：可以将负载分布在多个slave上以提高性能。所有的写操作都必须在master上进行，但是读操作可以分布在一个或多个slave上。这样的模型可以提高写入性能，因为master专注于数据更新，同时多个slave可以显著的提高读取速度。&lt;/li&gt;
&lt;li&gt;数据安全：定期备份是保护数据的重要手段之一，若在master上进行数据备份则需要使master处于readonly状态，这将影响写操作 。而salve可以暂停复制的过程，所以slave上进行数据备份而不会影响到master。&lt;/li&gt;
&lt;li&gt;分析：数据是从master上实时写入的，数据分析可以在slave上进行而不影响master的性能。&lt;/li&gt;
&lt;li&gt;远程数据分发：如果master的物理位置距离较远，我们可以在临近的地方创建slave，方便使用数据使用，而不需要总是访问远端的master。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;作为master 的MySQL实例将数据的变更操作作为”事件”记录到&lt;code&gt;binary log&lt;/code&gt;中，slave 的MySQL实例被被指为读取master的&lt;code&gt;binary log&lt;/code&gt;，slave将读取到的&lt;code&gt;binary log&lt;/code&gt;写入自己的中继日志中，然后slave回把相关的事件进行执行。slave具体执行哪些事件由slave决定。&lt;/p&gt;
&lt;h4 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h4&gt;&lt;h5 id=&quot;创建用于复制的账号&quot;&gt;&lt;a href=&quot;#创建用于复制的账号&quot; class=&quot;headerlink&quot; title=&quot;创建用于复制的账号&quot;&gt;&lt;/a&gt;创建用于复制的账号&lt;/h5&gt;&lt;p&gt;进入master的MySQL实例，执行以下操作：&lt;/p&gt;
&lt;p&gt;执行以下命令创建账号，其中&lt;code&gt;172.20.254.176&lt;/code&gt;为slave的MySQL的ip，&lt;code&gt;liuqitech@2020&lt;/code&gt;为密码。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://100067.xyz/categories/Linux/"/>
    
    
      <category term="MySQL" scheme="https://100067.xyz/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 安装 JDK</title>
    <link href="https://100067.xyz/2020/02/26/centos7_jdk/"/>
    <id>https://100067.xyz/2020/02/26/centos7_jdk/</id>
    <published>2020-02-26T02:00:00.000Z</published>
    <updated>2020-03-03T11:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><p>确保使用<em>root</em>用户或具有<em>sudo</em>权限的用户登陆。</p><h4 id="OpenJDK"><a href="#OpenJDK" class="headerlink" title="OpenJDK"></a>OpenJDK</h4><p>通过<code>yum search</code>命令查看java相关包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search java | grep openjdk</span><br></pre></td></tr></table></figure><table><thead><tr><th>版本</th><th>jre</th><th>jdk</th></tr></thead><tbody><tr><td>11</td><td>java-11-openjdk.x86_64</td><td>java-11-openjdk-devel.x86_64</td></tr><tr><td>1.8</td><td>java-1.8.0-openjdk.x86_64</td><td>java-1.8.0-openjdk-headless.x86_64</td></tr></tbody></table><p>以安装11版本的jdk为例</p><p>安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java-11-openjdk-devel.x86_64</span><br></pre></td></tr></table></figure><p>卸载命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove java-11-openjdk-devel.x86_64</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Oracle-JDK"><a href="#Oracle-JDK" class="headerlink" title="Oracle JDK"></a>Oracle JDK</h4><p>Oracle 的 JDK 需要从Oracle的官网下载来进行安装</p><table><thead><tr><th>版本</th><th>jre</th><th>jdk</th></tr></thead><tbody><tr><td>11</td><td><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></td><td><a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk11-downloads.html</a></td></tr><tr><td>1.8</td><td><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></td><td><a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</a></td></tr></tbody></table><p>以安装11版本的jdk为例。下载<em>jdk-11.0.6_linux-x64_bin.rpm</em></p><p>安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum localinstall jdk-11_linux-x64_bin.rpm</span><br></pre></td></tr></table></figure><p>卸载命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看已安装的jdk包</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line"># 卸载(其中jdk-11-11-ga.x86_64为软件包名)</span><br><span class="line">rpm -e jdk-11-11-ga.x86_64</span><br></pre></td></tr></table></figure><h4 id="设置默认的版本"><a href="#设置默认的版本" class="headerlink" title="设置默认的版本"></a>设置默认的版本</h4><p>查看当前系统默认java版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version &quot;11.0.6&quot; 2020-01-14 LTS</span><br><span class="line">OpenJDK Runtime Environment 18.9 (build 11.0.6+10-LTS)</span><br><span class="line">OpenJDK 64-Bit Server VM 18.9 (build 11.0.6+10-LTS, mixed mode, sharing)</span><br></pre></td></tr></table></figure><p>如果安装了多个版本，可以按以下操作进行切换默认版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo alternatives --config java</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">There are 2 programs which provide &apos;java&apos;.</span><br><span class="line"></span><br><span class="line">  Selection    Command</span><br><span class="line">-----------------------------------------------</span><br><span class="line">   1           java-11-openjdk.x86_64 (/usr/lib/jvm/java-11-openjdk-11.0.6.10-1.el7_7.x86_64/bin/java)</span><br><span class="line">*+ 2           /usr/java/jdk-11/bin/java</span><br><span class="line"></span><br><span class="line">Enter to keep the current selection[+], or type selection number:</span><br></pre></td></tr></table></figure><p>通过输入对应数字并按Enter即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h4&gt;&lt;p&gt;确保使用&lt;em&gt;root&lt;/em&gt;用户或具有&lt;em&gt;sudo&lt;/em&gt;权限的用户登陆。&lt;/p&gt;
&lt;h4 id=&quot;OpenJDK&quot;&gt;&lt;a href=&quot;#OpenJDK&quot; class=&quot;headerlink&quot; title=&quot;OpenJDK&quot;&gt;&lt;/a&gt;OpenJDK&lt;/h4&gt;&lt;p&gt;通过&lt;code&gt;yum search&lt;/code&gt;命令查看java相关包&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum search java | grep openjdk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;jre&lt;/th&gt;
&lt;th&gt;jdk&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;java-11-openjdk.x86_64&lt;/td&gt;
&lt;td&gt;java-11-openjdk-devel.x86_64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.8&lt;/td&gt;
&lt;td&gt;java-1.8.0-openjdk.x86_64&lt;/td&gt;
&lt;td&gt;java-1.8.0-openjdk-headless.x86_64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;以安装11版本的jdk为例&lt;/p&gt;
&lt;p&gt;安装命令如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install java-11-openjdk-devel.x86_64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;卸载命令如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo yum remove java-11-openjdk-devel.x86_64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://100067.xyz/categories/Linux/"/>
    
    
      <category term="Java" scheme="https://100067.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>去广告规则</title>
    <link href="https://100067.xyz/2020/02/14/ad_block_filter/"/>
    <id>https://100067.xyz/2020/02/14/ad_block_filter/</id>
    <published>2020-02-14T14:00:50.000Z</published>
    <updated>2021-09-03T04:40:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="适用于-Adblock-Plus-AdGuard-uBlock-等"><a href="#适用于-Adblock-Plus-AdGuard-uBlock-等" class="headerlink" title="适用于 Adblock Plus/AdGuard/uBlock 等"></a>适用于 Adblock Plus/AdGuard/uBlock 等</h4><ul><li><p>EasyList + EasyList China</p><blockquote><p><a href="https://easylist-downloads.adblockplus.org/easylistchina+easylist.txt" target="_blank" rel="noopener">https://easylist-downloads.adblockplus.org/easylistchina+easylist.txt</a></p></blockquote></li><li><p><a href="https://github.com/cjx82630/cjxlist" target="_blank" rel="noopener">CJX’s Annoyance List</a></p><p>这是”EasyList China+EasyList” &amp; “EasyPrivacy”的补充.过滤烦人的自我推广,并补充EasyPrivacy隐私规则</p><blockquote><p> <a href="https://raw.githubusercontent.com/cjx82630/cjxlist/master/cjx-annoyance.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/cjx82630/cjxlist/master/cjx-annoyance.txt</a></p></blockquote></li><li><p><a href="https://gitee.com/halflife/list" target="_blank" rel="noopener">合并规则EasylistChina、EasylistLite、CJX’sAnnoyance</a></p><p>合并EasylistChina、EasylistLite、CJX’sAnnoyance，以及补充的一些规则；</p><blockquote><p><a href="https://gitee.com/halflife/list/raw/master/ad.txt" target="_blank" rel="noopener">https://gitee.com/halflife/list/raw/master/ad.txt</a></p></blockquote></li><li><p><a href="http://bbs.kafan.cn/thread-1866845-1-1.html" target="_blank" rel="noopener">乘风 广告过滤规则</a></p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/xinggsf/Adblock-Plus-Rule@master/rule.txt" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/xinggsf/Adblock-Plus-Rule@master/rule.txt</a></p></blockquote><a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;适用于-Adblock-Plus-AdGuard-uBlock-等&quot;&gt;&lt;a href=&quot;#适用于-Adblock-Plus-AdGuard-uBlock-等&quot; class=&quot;headerlink&quot; title=&quot;适用于 Adblock Plus/AdGuard/uBlock 等&quot;&gt;&lt;/a&gt;适用于 Adblock Plus/AdGuard/uBlock 等&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;EasyList + EasyList China&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://easylist-downloads.adblockplus.org/easylistchina+easylist.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://easylist-downloads.adblockplus.org/easylistchina+easylist.txt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/cjx82630/cjxlist&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CJX’s Annoyance List&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是”EasyList China+EasyList” &amp;amp; “EasyPrivacy”的补充.过滤烦人的自我推广,并补充EasyPrivacy隐私规则&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;a href=&quot;https://raw.githubusercontent.com/cjx82630/cjxlist/master/cjx-annoyance.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/cjx82630/cjxlist/master/cjx-annoyance.txt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://gitee.com/halflife/list&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;合并规则EasylistChina、EasylistLite、CJX’sAnnoyance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;合并EasylistChina、EasylistLite、CJX’sAnnoyance，以及补充的一些规则；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/halflife/list/raw/master/ad.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gitee.com/halflife/list/raw/master/ad.txt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://bbs.kafan.cn/thread-1866845-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;乘风 广告过滤规则&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://cdn.jsdelivr.net/gh/xinggsf/Adblock-Plus-Rule@master/rule.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cdn.jsdelivr.net/gh/xinggsf/Adblock-Plus-Rule@master/rule.txt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="net" scheme="https://100067.xyz/categories/net/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL COALESCE 函数</title>
    <link href="https://100067.xyz/2020/02/14/mysql_coalesce/"/>
    <id>https://100067.xyz/2020/02/14/mysql_coalesce/</id>
    <published>2020-02-14T03:26:00.000Z</published>
    <updated>2020-02-14T04:03:35.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce" target="_blank" rel="noopener"><code>COALESCE(value,...)</code></a>  </p><p>Returns the first non-<code>NULL</code> value in the list, or <code>NULL</code> if there are no non-<code>NULL</code> values.</p><p>官方文档介绍的很清楚，该函数返回参数列表中第一个非NULL的值，如果没有非NULL的值则返回NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COALESCE(NULL,1);</span><br><span class="line">        -&gt; 1</span><br><span class="line">mysql&gt; SELECT COALESCE(NULL,NULL,NULL);</span><br><span class="line">        -&gt; NULL</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>表中存在字段<code>create_time</code>、<code>update_time</code>，现在需要按更新时间倒序排序，由于更新时间可能为NULL，若为NULL时按创建时间排。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORDER BY COALESCE(update_time, create_time) DESC</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;COALESCE(value,...)&lt;/code&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;Returns the first non-&lt;code&gt;NULL&lt;/code&gt; value in the list, or &lt;code&gt;NULL&lt;/code&gt; if there are no non-&lt;code&gt;NULL&lt;/code&gt; values.&lt;/p&gt;
&lt;p&gt;官方文档介绍的很清楚，该函数返回参数列表中第一个非NULL的值，如果没有非NULL的值则返回NULL。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; SELECT COALESCE(NULL,1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; SELECT COALESCE(NULL,NULL,NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        -&amp;gt; NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://100067.xyz/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://100067.xyz/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>中兴 E8820 V2 资料</title>
    <link href="https://100067.xyz/2020/02/03/zxhn_e8820v2/"/>
    <id>https://100067.xyz/2020/02/03/zxhn_e8820v2/</id>
    <published>2020-02-03T08:26:50.000Z</published>
    <updated>2020-02-04T03:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>ZXHN E8820 V2是一款支持IEEE802.11ac的智能无线路由器，支持双频最高1200Mbps（5G 900M和2.4G 300M）无线传输，支持1个GE上网口，4个GE用户端接口，支持USB端口，可外接移动硬盘进行家庭私有云备份。</p><h4 id="硬件参数"><a href="#硬件参数" class="headerlink" title="硬件参数"></a>硬件参数</h4><p>用户接口 4GE+1USB+Wi-Fi<br>上行接口 GE<br>设备尺寸 222 mm (L) x 150mm(W) x 36 mm (H)<br>设备重量 0.25(kg)<br>工作环境 0℃～+40℃<br>相对湿度 10%－90%（非凝结）<br>电源适配器: 输入100-240VAC,输出 12VDC, 1.5A</p><a id="more"></a><h4 id="官方固件"><a href="#官方固件" class="headerlink" title="官方固件"></a>官方固件</h4><p>2.03、2.07 版本的官方web升级文件: <a href="https://72k.us/dir/22553047-37127644-e78cd2" target="_blank" rel="noopener">https://72k.us/dir/22553047-37127644-e78cd2</a> 提取密码:156276</p><h4 id="第三方固件"><a href="#第三方固件" class="headerlink" title="第三方固件"></a>第三方固件</h4><p>OPENWRT: <a href="https://www.right.com.cn/forum/thread-506561-1-1.html" target="_blank" rel="noopener">https://www.right.com.cn/forum/thread-506561-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;p&gt;ZXHN E8820 V2是一款支持IEEE802.11ac的智能无线路由器，支持双频最高1200Mbps（5G 900M和2.4G 300M）无线传输，支持1个GE上网口，4个GE用户端接口，支持USB端口，可外接移动硬盘进行家庭私有云备份。&lt;/p&gt;
&lt;h4 id=&quot;硬件参数&quot;&gt;&lt;a href=&quot;#硬件参数&quot; class=&quot;headerlink&quot; title=&quot;硬件参数&quot;&gt;&lt;/a&gt;硬件参数&lt;/h4&gt;&lt;p&gt;用户接口 4GE+1USB+Wi-Fi&lt;br&gt;上行接口 GE&lt;br&gt;设备尺寸 222 mm (L) x 150mm(W) x 36 mm (H)&lt;br&gt;设备重量 0.25(kg)&lt;br&gt;工作环境 0℃～+40℃&lt;br&gt;相对湿度 10%－90%（非凝结）&lt;br&gt;电源适配器: 输入100-240VAC,输出 12VDC, 1.5A&lt;/p&gt;
    
    </summary>
    
      <category term="net" scheme="https://100067.xyz/categories/net/"/>
    
    
      <category term="路由器" scheme="https://100067.xyz/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java中的强引用、软引用、弱引用、虚引用</title>
    <link href="https://100067.xyz/2020/01/15/java-reference/"/>
    <id>https://100067.xyz/2020/01/15/java-reference/</id>
    <published>2020-01-15T10:06:50.000Z</published>
    <updated>2020-01-15T10:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 对象的引用划分为4种，它们由强到弱依次是<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>、<strong>虚引用</strong>。这样划分的作用是可以更好的控制对象的声明周期，有利于JVM 进行垃圾回收。</p><a id="more"></a><h5 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h5><p>强引用就是我们最常见的普通对象引用，通常我们通过<code>new</code>来创建的对象所产生的引用就是强引用，强引用的对象不可被JVM垃圾收集器回收。</p><p>比如下面这段代码，<code>obj</code>和<code>str</code>都是强引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">String str = &quot;liuqitech&quot;;</span><br></pre></td></tr></table></figure><p>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OOM的错误也不会回收这种对象。比如下面的代码中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Main().fun1();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void fun1() &#123;</span><br><span class="line">        Object object = new Object();</span><br><span class="line">        Object[] objArr = new Object[1000];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行至<code>Object[] objArr = new Object[1000];</code>时，即使内存不足抛出OOM错误，也不会回收<code>object</code>所引用的对象。不过要注意的是当<code>fun1()</code>方法执行完毕后，<code>object</code>、<code>objArr</code>都已经不存在，所以他们指向的对象会被JVM回收。</p><p>如果想中队强引用和某个对象之间的关联，可以显示的将引用赋值为null（如object = null）,这样JVM就会在合适的时机回收原<code>object</code>所指向的对象。</p><h5 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h5><p>软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(&quot;hello&quot;));</span><br><span class="line">System.out.println(sr.get());</span><br></pre></td></tr></table></figure><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被回收，则这个软引用进入到与之关联的引用队列中。</p><h5 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h5><p>弱引用并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     </span><br><span class="line">        WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String(&quot;hello&quot;));</span><br><span class="line">         </span><br><span class="line">        System.out.println(sr.get()); // hello</span><br><span class="line">        System.gc();                //通知JVM的gc进行垃圾回收</span><br><span class="line">        System.out.println(sr.get()); // null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样弱引用也可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被回收，则将这个若引用进入到与之关联的引用队列中。</p><h5 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h5><p>虚引用也被翻译为幻象引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用必须和引用队列联合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;();</span><br><span class="line">        PhantomReference&lt;String&gt; pr = new PhantomReference&lt;String&gt;(new String(&quot;hello&quot;), queue);</span><br><span class="line">        System.out.println(pr.get()); // null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h5><h5 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h5><p><a href="https://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3784171.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 对象的引用划分为4种，它们由强到弱依次是&lt;strong&gt;强引用&lt;/strong&gt;、&lt;strong&gt;软引用&lt;/strong&gt;、&lt;strong&gt;弱引用&lt;/strong&gt;、&lt;strong&gt;虚引用&lt;/strong&gt;。这样划分的作用是可以更好的控制对象的声明周期，有利于JVM 进行垃圾回收。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://100067.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="https://100067.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记 - Spring AOP 使用</title>
    <link href="https://100067.xyz/2020/01/06/spring-aop-use/"/>
    <id>https://100067.xyz/2020/01/06/spring-aop-use/</id>
    <published>2020-01-06T08:30:00.000Z</published>
    <updated>2020-01-06T09:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义-Aspect"><a href="#定义-Aspect" class="headerlink" title="定义 Aspect"></a>定义 Aspect</h4><p>定义一个Aspect，只需要我们定义一个最普通的POJO，然后在类上加上<code>@Aspect</code>注解即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明-Pointcut"><a href="#声明-Pointcut" class="headerlink" title="声明 Pointcut"></a>声明 Pointcut</h4><p>Pointcut 的声明，依附在<code>@Aspect</code>所标注的Asepct定义类之内，通过使用<code>@Pointcut</code>注解，指定Pointcut表达式之后，将这个指定了相应表达式的注解标注到Aspect定义类的某个方法上即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">  @Pointcut(&quot;execution(void *.method1()) || execution(void *.method2())&quot;)</span><br><span class="line">  public void pointcut1()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pointcut 声明包含两部分</p><ul><li>Pointcut Expression，切点表达式。它用来规定Pointcut匹配规则。</li><li>Pointcut Signature，切点签名。它是一个具体化的方法定义，是Pointcut Expression的载体。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">  @Pointcut(&quot;execution(void *.method1())&quot;) //Pointcut Expression</span><br><span class="line">  public void pointcut1()&#123;&#125;; //Pointcut Signature</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们就简单定义了一个pointcut，它将匹配到所有方法名为method1且返回值为void的方法。</p><h5 id="Pointcut标志符（Pointcut-Designator）"><a href="#Pointcut标志符（Pointcut-Designator）" class="headerlink" title="Pointcut标志符（Pointcut Designator）"></a>Pointcut标志符（Pointcut Designator）</h5><p>上面例子<code>execution(void *.method1())</code>中的<code>execution</code>即为Pointcut标志符。它表明该Pointcut将以什么样的行为来匹配表达式。</p><ul><li><em>execution</em> - 匹配指定方法。</li><li><em>within</em> - 匹配指定类下所声明的所有方法。如<code>withIn(com.liuqitech.spring.aop.MoctTarget)</code>它将匹配<code>MockTarget</code>类中所有声明的方法。</li><li><em>this</em> - limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type</li><li><em>target</em> - limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type</li><li><em>args</em> - 匹配参数满足要求的方法。如<code>args(com.liuqitech.spring.aop.domain.User)</code> 它将匹配所有仅有一个入参且类型为<code>com.liuqitech.spring.aop.domain.User</code>的方法（比如：<code>public boolean login(User user){...}</code>、<code>public boolean isLogin(User){...}</code>）</li><li><em><code>@target</code></em> - limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type</li><li><em><code>@args</code></em> - 匹配入参被某注解标注的方法。</li><li><em><code>@within</code></em> - 匹配使用了某注解的类下所有的方法。比如<code>@withIn(org.springframework.stereotype.Component)</code> 它将匹配所有使用了<code>@Component</code>注解的类下所有声明的方法。</li><li><em>@annotation</em> - 匹配使用了某注解的方法。</li></ul><h4 id="声明Advice"><a href="#声明Advice" class="headerlink" title="声明Advice"></a>声明Advice</h4><p>它实际上就是使用<code>@Aspect</code>标注的Aspect定义类中的不同方法，只不过这些方法需要针对不同的Advice类型使用对应的注解进行标注。</p><ul><li>@Before，前置增强</li><li>@AfterReturning，后置增强，</li><li>@AfterThrowing，抛出增强</li><li>@After，Final增强</li><li>@Around，环绕增强</li><li>@DeclareParents，引介增强</li></ul><p>除了<code>@DeclareParents</code>比较不同之外，其他用于标注不同类型Advice的注解，全都是方法级别的注解定义，只能用于标注方法定义。同时，各种Advice最终织入到什么位置，是由相应的Pointcut定义决定的。所以我们需要为这些用于标注Advice的注解指定对应的Pointcut定义，可以直接使用的Pointcut表达式，也可以指定上面单独声明的@Pointcut类型的Pointcut Signature。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line"></span><br><span class="line">  @Pointcut(&quot;execution(void *.method1()) || execution(void *.method2())&quot;)</span><br><span class="line">  public void pointcut1()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  @Before(&quot;pointcut1()&quot;) //使用已经定义的Pointcut签名</span><br><span class="line">  public void doSomething1() &#123;</span><br><span class="line">    System.out.println(&quot;do something 1...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @After(&quot;execution(void *.method1())&quot;) //直接使用Pointcut表达式</span><br><span class="line">  public void doSomething2() &#123;</span><br><span class="line">    System.out.println(&quot;do something 2...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AfterThrowing-示例"><a href="#AfterThrowing-示例" class="headerlink" title="@AfterThrowing 示例"></a>@AfterThrowing 示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AfterThrowingExample &#123;</span><br><span class="line"></span><br><span class="line">  @AfterThrowing(</span><br><span class="line">    pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span><br><span class="line">    throwing=&quot;ex&quot;)</span><br><span class="line">  public void doRecoveryActions(DataAccessException ex) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有一个独特的属性<code>throwing</code>，通过它我们可以限定Advice定义方法的参数名，并在方法调用的时候，将相应的异常绑定到具体方法参数上。当然如果不需要访问具体异常，那么我们可以声明没有任何参数的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@AfterThrowing(pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span><br><span class="line">  public void doRecoveryActions() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="AfterReturning-示例"><a href="#AfterReturning-示例" class="headerlink" title="@AfterReturning 示例"></a>@AfterReturning 示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AfterReturningExample &#123;</span><br><span class="line"></span><br><span class="line">  @AfterReturning(</span><br><span class="line">    pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span><br><span class="line">    returning=&quot;retVal&quot;)</span><br><span class="line">  public void doAccessCheck(Object retVal) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它也有一个独特的属性<code>returning</code>，它能获取方法的返回值。当然如果我们不需要方法返回值时，也可以去掉该属性。</p><h5 id="Around-示例"><a href="#Around-示例" class="headerlink" title="@Around 示例"></a>@Around 示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AroundExample &#123;</span><br><span class="line"></span><br><span class="line">  @Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)</span><br><span class="line">  public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">    // start stopwatch</span><br><span class="line">    Object retVal = pjp.proceed();</span><br><span class="line">    // stop stopwatch</span><br><span class="line">    return retVal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类型的方法定义中，第一个参数必须是<code>ProceedingJoinPoint</code>类型，我们需要通过ProceedingJoinPoint的proceed()方法继续执行调用链。</p><h4 id="Spring-AOP-相关笔记"><a href="#Spring-AOP-相关笔记" class="headerlink" title="Spring AOP 相关笔记"></a>Spring AOP 相关笔记</h4><p><a href="http://liuqitech.com/2020/01/03/spring-aop-concept/">Spring学习笔记 - Spring AOP 概述</a></p><p><a href="http://liuqitech.com/2020/01/06/spring-aop-use/">Spring学习笔记 - Spring AOP 使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;定义-Aspect&quot;&gt;&lt;a href=&quot;#定义-Aspect&quot; class=&quot;headerlink&quot; title=&quot;定义 Aspect&quot;&gt;&lt;/a&gt;定义 Aspect&lt;/h4&gt;&lt;p&gt;定义一个Aspect，只需要我们定义一个最普通的POJO，然后在类上加上&lt;code&gt;@Aspect&lt;/code&gt;注解即可。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Aspect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class MyAspect &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;声明-Pointcut&quot;&gt;&lt;a href=&quot;#声明-Pointcut&quot; class=&quot;headerlink&quot; title=&quot;声明 Pointcut&quot;&gt;&lt;/a&gt;声明 Pointcut&lt;/h4&gt;&lt;p&gt;Pointcut 的声明，依附在&lt;code&gt;@Aspect&lt;/code&gt;所标注的Asepct定义类之内，通过使用&lt;code&gt;@Pointcut&lt;/code&gt;注解，指定Pointcut表达式之后，将这个指定了相应表达式的注解标注到Aspect定义类的某个方法上即可。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Aspect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class MyAspect &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  @Pointcut(&amp;quot;execution(void *.method1()) || execution(void *.method2())&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  public void pointcut1()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Pointcut 声明包含两部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pointcut Expression，切点表达式。它用来规定Pointcut匹配规则。&lt;/li&gt;
&lt;li&gt;Pointcut Signature，切点签名。它是一个具体化的方法定义，是Pointcut Expression的载体。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://100067.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="https://100067.xyz/tags/Java/"/>
    
      <category term="Spring" scheme="https://100067.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记 - Spring AOP 概述</title>
    <link href="https://100067.xyz/2020/01/03/spring-aop-concept/"/>
    <id>https://100067.xyz/2020/01/03/spring-aop-concept/</id>
    <published>2020-01-03T09:30:00.000Z</published>
    <updated>2020-01-06T09:31:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="AOP中涉及的概念"><a href="#AOP中涉及的概念" class="headerlink" title="AOP中涉及的概念"></a>AOP中涉及的概念</h4><ul><li><p>Joinpoint</p><p>在系统运行之前，AOP的功能模块都需要植入到OOP的功能模块中。所以，要进行这些植入过程，我们需要知道再系统的哪些执行点上进行织入操作，这些将要在其之上进行植入操作的系统执行点就称之为Joinpoint。</p></li><li><p>Pointcut</p><p>Pointcut概念代表的是Joinpoint的表述方式。将横切逻辑织入当前系统的过程中，需要参照Pointcut规定的Joinpoint信息，才可以知道应该往系统的哪些Joinpoint上织入横切逻辑。</p></li><li><p>Advice</p><p>Advice是单一横切关注点逻辑的载体，它代表将会织入到Joinpoint的横切逻辑。</p></li><li><p>Aspect</p><p>Aspect是对系统中的横切关注点逻辑进行模块化封装的AOP概念实体。通常情况下，Aspect可以包含多个Pointcut以及相关的Advice定义。</p></li><li><p>织入和织入器</p><p>织入（Weaving）的过程就是将横切逻辑融合到原系统中的过程。只有经过织入过程以后，以Aspect模块话的横切关注点才会集成到OOP的现存系统中。完成织入过程的“人”就称之为织入器（Weaver）。</p></li><li><p>目标对象</p><p>符合Pointcut所指定的条件，将在织入过程中被织入横切逻辑的对象，称之为目标对象（Target Object）。</p></li></ul><a id="more"></a><h4 id="Java-平台上的AOP实现机制"><a href="#Java-平台上的AOP实现机制" class="headerlink" title="Java 平台上的AOP实现机制"></a>Java 平台上的AOP实现机制</h4><ul><li><p>动态代理</p><p>JDK 1.3之后，引入了动态代理（Dynamic Proxy）机制，可以在运行期间，为响应的接口（Interface）动态生成对应的代理对象。所以，我们可以将横切关注点逻辑封装到动态代理的InvocationHandler中，然后在系统的运行期间，根据横切关注点需要织入的模块位置，将横切逻辑织入到相应的代理类中。</p></li><li><p>动态字节码增强</p><p>我们知道，我们可以可以使用CGLIB等类似的动态字节码增强的工具库，在程序运行期间动态构建字节码class文件。这样我们可以为需要织入横切逻辑的模块类在运行期间通过动态字节码增强技术为这些系统模块类生成相应的子类，将横切逻辑假如到这些子类中。</p></li><li><p>Java代码生成</p><p>这种方式比较古老，不做了解。</p></li><li><p>自定义类加载器</p><p>所有的Java程序的class都要通过相应的类加载器（Classloader）加载到Java虚拟机之后才能运行。</p><p>所以我们可以通过自定义类加载器，在class文件加载到虚拟机的解析过程中，将横切逻辑织入到class文件中来达到目的。</p></li><li><p>AOL扩展</p><p>此处暂时略过，该方式我也不太了解。</p></li></ul><h4 id="Spring-AOP-的实现机制"><a href="#Spring-AOP-的实现机制" class="headerlink" title="Spring AOP 的实现机制"></a>Spring AOP 的实现机制</h4><p>Spring AOP 采用了动态代理机制和动态字节码增强技术来实现。</p><h4 id="Spring-AOP-相关笔记"><a href="#Spring-AOP-相关笔记" class="headerlink" title="Spring AOP 相关笔记"></a>Spring AOP 相关笔记</h4><p><a href="http://liuqitech.com/2020/01/03/spring-aop-concept/">Spring学习笔记 - Spring AOP 概述</a></p><p><a href="http://liuqitech.com/2020/01/06/spring-aop-use/">Spring学习笔记 - Spring AOP 使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;AOP中涉及的概念&quot;&gt;&lt;a href=&quot;#AOP中涉及的概念&quot; class=&quot;headerlink&quot; title=&quot;AOP中涉及的概念&quot;&gt;&lt;/a&gt;AOP中涉及的概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Joinpoint&lt;/p&gt;
&lt;p&gt;在系统运行之前，AOP的功能模块都需要植入到OOP的功能模块中。所以，要进行这些植入过程，我们需要知道再系统的哪些执行点上进行织入操作，这些将要在其之上进行植入操作的系统执行点就称之为Joinpoint。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pointcut&lt;/p&gt;
&lt;p&gt;Pointcut概念代表的是Joinpoint的表述方式。将横切逻辑织入当前系统的过程中，需要参照Pointcut规定的Joinpoint信息，才可以知道应该往系统的哪些Joinpoint上织入横切逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Advice&lt;/p&gt;
&lt;p&gt;Advice是单一横切关注点逻辑的载体，它代表将会织入到Joinpoint的横切逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Aspect&lt;/p&gt;
&lt;p&gt;Aspect是对系统中的横切关注点逻辑进行模块化封装的AOP概念实体。通常情况下，Aspect可以包含多个Pointcut以及相关的Advice定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;织入和织入器&lt;/p&gt;
&lt;p&gt;织入（Weaving）的过程就是将横切逻辑融合到原系统中的过程。只有经过织入过程以后，以Aspect模块话的横切关注点才会集成到OOP的现存系统中。完成织入过程的“人”就称之为织入器（Weaver）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目标对象&lt;/p&gt;
&lt;p&gt;符合Pointcut所指定的条件，将在织入过程中被织入横切逻辑的对象，称之为目标对象（Target Object）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://100067.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="https://100067.xyz/tags/Java/"/>
    
      <category term="Spring" scheme="https://100067.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记 - Spring FactoryBean</title>
    <link href="https://100067.xyz/2020/01/02/spring-factorybean/"/>
    <id>https://100067.xyz/2020/01/02/spring-factorybean/</id>
    <published>2020-01-02T07:00:00.000Z</published>
    <updated>2020-01-03T09:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p><code>org.springframework.beans.factory.FactoryBean&lt;T&gt;</code>是<code>Spring</code>容器提供的一种可以扩展容器对象实例化逻辑的接口。<code>FactoryBean</code>，其主语是Ben，定于为Factory，也就是说，它本身与其他注册到容器中的对象一样，只是一个Bean而已，只不过这种类型的Bean本身就是生产对象的工厂。</p><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><p>它的接口定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">  @Nullable</span><br><span class="line">  T getObject() throws Exception;</span><br><span class="line">  @Nullable</span><br><span class="line">  Class&lt;?&gt; getObjectType();</span><br><span class="line">  default boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getObject()</code>方法会返回该<code>FactoryBean</code>“生产”的对象实例，我们需要实现该方法以给出自己的对象实例化逻辑；<code>getObjectType()</code>方法仅返回<code>getObject()</code>方法所返回的对象的类型，如果预先无法确定，则返回null；<code>isSingleton()</code>方法返回结果用于表明，工厂方法（<code>getObject()</code>）所“生产”的对象是否要以singleton形式存在于容器中。如果以singleton形式存在，则返回true，否则返回false； </p><a id="more"></a><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>FactoryBean</code>的一般使用场景是，当我们需要实例化一个比较复杂的Bean时，我们可以通过实现<code>FactoryBean</code>来定制Bean的实例化过程。</p><p>在IOC容器中，通过<code>getBean(BeanName)</code>方法获取Bean时，如果该Bean实现了<code>FactoryBean</code>接口，则获取到该Bean的实例为<code>getObjet()</code>方法返回的结果，并不是<code>FactoryBean</code>的实现类对象。</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>我们实现一个<code>FactoryBean</code>示例，我们将实现一个<code>ToolFactory</code>，它将产生Tool类型的实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Tool &#123;</span><br><span class="line"> </span><br><span class="line">    private int id;</span><br><span class="line"> </span><br><span class="line">    // standard constructors, getters and setters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ToolFactory implements FactoryBean&lt;Tool&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    private int factoryId;</span><br><span class="line">    private int toolId;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Tool getObject() throws Exception &#123;</span><br><span class="line">        return new Tool(toolId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return Tool.class;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public boolean isSingleton() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // standard setters and getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使<code>ToolFactory</code>生效（将<code>FactoryBean</code>的实现注册到IOC容器中），有以下两种方式：</p><ul><li><p>XML</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans ...&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;bean id=&quot;tool&quot; class=&quot;com.baeldung.factorybean.ToolFactory&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;factoryId&quot; value=&quot;9090&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;toolId&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>Java编码</p><p>与XML不同的是，我们需要显示的调用<code>getObject()</code>方法来生成实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FactoryBeanAppConfig &#123;</span><br><span class="line">  </span><br><span class="line">    @Bean(name = &quot;tool&quot;)</span><br><span class="line">    public ToolFactory toolFactory() &#123;</span><br><span class="line">        ToolFactory factory = new ToolFactory();</span><br><span class="line">        factory.setFactoryId(7070);</span><br><span class="line">        factory.setToolId(2);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Bean</span><br><span class="line">    public Tool tool() throws Exception &#123;</span><br><span class="line">        return toolFactory().getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用时，直接引入Tool实例对象即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryBeanTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Tool tool;</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        assertThat(tool.getId(), equalTo(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h4&gt;&lt;p&gt;&lt;code&gt;org.springframework.beans.factory.FactoryBean&amp;lt;T&amp;gt;&lt;/code&gt;是&lt;code&gt;Spring&lt;/code&gt;容器提供的一种可以扩展容器对象实例化逻辑的接口。&lt;code&gt;FactoryBean&lt;/code&gt;，其主语是Ben，定于为Factory，也就是说，它本身与其他注册到容器中的对象一样，只是一个Bean而已，只不过这种类型的Bean本身就是生产对象的工厂。&lt;/p&gt;
&lt;h4 id=&quot;接口定义&quot;&gt;&lt;a href=&quot;#接口定义&quot; class=&quot;headerlink&quot; title=&quot;接口定义&quot;&gt;&lt;/a&gt;接口定义&lt;/h4&gt;&lt;p&gt;它的接口定义如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface FactoryBean&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  @Nullable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  T getObject() throws Exception;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  @Nullable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Class&amp;lt;?&amp;gt; getObjectType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  default boolean isSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;getObject()&lt;/code&gt;方法会返回该&lt;code&gt;FactoryBean&lt;/code&gt;“生产”的对象实例，我们需要实现该方法以给出自己的对象实例化逻辑；&lt;code&gt;getObjectType()&lt;/code&gt;方法仅返回&lt;code&gt;getObject()&lt;/code&gt;方法所返回的对象的类型，如果预先无法确定，则返回null；&lt;code&gt;isSingleton()&lt;/code&gt;方法返回结果用于表明，工厂方法（&lt;code&gt;getObject()&lt;/code&gt;）所“生产”的对象是否要以singleton形式存在于容器中。如果以singleton形式存在，则返回true，否则返回false； &lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://100067.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="https://100067.xyz/tags/Java/"/>
    
      <category term="Spring" scheme="https://100067.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>git flow 简单入门 | SourceTree操作Git工作流</title>
    <link href="https://100067.xyz/2019/12/26/git-flow-learn/"/>
    <id>https://100067.xyz/2019/12/26/git-flow-learn/</id>
    <published>2019-12-26T08:26:50.000Z</published>
    <updated>2022-02-08T10:26:46.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Git 作为源码管理系统，不可避免涉及到多人协作。团队中商定一个工作流程至关重要的。本文已常用的Git flow 做说明，该模型如下图所示：</p><p><img src="https://nvie.com/img/git-model@2x.png" alt="image"></p><a id="more"></a><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>该模型总存在两个长期（核心）分支：</p><ul><li>master</li><li>develop</li></ul><p><code>master</code> ，我们认为该分支存放对外发布的版本，任何时候该分支都是稳定的发布版。我们不可以直接在该分支push 代码。</p><p><code>develop</code> ，我们认为该分支的代码存放的是达到稳定并且准备发布时的，我们的新功能开发都是基于此分支。</p><p>其次，项目存在的三种短期分支：</p><ul><li>feature</li><li>hotfix</li><li>release</li></ul><p><code>feature</code> ，即功能分支，我们进行新功能的开发将在此分支上进行。该分支的代码基于develop 并且最终回合并回develop 分支。</p><p><code>hoxtfix</code> , 即补丁分支，我们进行线上问题修复将在此分支进行，该代码分支基于master 并且最终将合并会develop、master 分支。</p><p> <code>release</code>, 即预发分支。</p><h3 id="操作流程实例"><a href="#操作流程实例" class="headerlink" title="操作流程实例"></a>操作流程实例</h3><p>当我们进行新功能开发时，需要基于develop分支拉取feature分支进行开发，如增加了一个功能 我们将基于develop分支创建 feature/news 分支。</p><p>当功能开发完毕时，我们将提交merge request，将该功能合并到develop 分支。</p><p>当所有feature 功能开发完毕，且都已合并回develop，开发自己测试完毕后。准备创建预发布版本，就可以基于develop创建release分支。此时测试人员可以基于该版本release进行测试，发现了问题，我们在release分支上进行问题的修复。</p><p>当具备上线条件时，需要将release分支合并到master和develop分支，同时需要打tag，然后进行上线操作，线上发布的为master分支。</p><p>当需要修复线上bug时，我们需要基于master创建hotfix分支，当修复且验证完毕后，将hotfix分支合并回master分支，同时为了保证该hotfix包含在下一个发行版中，同时需要合并回develop分支，同时需要打tag。最后删除hotfix分支。</p><h3 id="SourceTree-操作"><a href="#SourceTree-操作" class="headerlink" title="SourceTree 操作"></a>SourceTree 操作</h3><p>SourceTree 的图形化界面git工具，可以简化我们上述的复杂操作。</p><ul><li><p>初始化项目</p><p>点击右上角Git工作流按钮，初始化git flow。</p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-1.png" alt="image"></p></li><li><p>开发新功能</p><p>点击创建新的功能，此时我们发现已经为我们创建了feature/news分支，我们将在此分支进行功能开发。</p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-2.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-3.png" alt="image"></p></li><li><p>开发完成</p><p>点击完成功能。 此时我们发现已经将feature/news分支合并到了develop分支。</p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-4.png" alt="image"></p></li><li><p>预发布 开始release</p><p>点击建立新的发布版本，此时我们发现已经为我们创建了release/v1.0.0 分支。</p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-5.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-6.png" alt="image"></p></li><li><p>发布 完成release</p><p>点击完成发布版本，此时我们发现已经将release/1.0.0分支合并到了develop和master</p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-7.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-8.png" alt="image"></p></li><li><p>线上问题修复 开始hotfix</p><p>点击创建新的修复补丁，此时我们发现基于master为我们创建了hotfix/v1.0.0-20191226</p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-9.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-10.png" alt="image"></p></li><li><p>完成问题修复 完成hotfix</p><p>点击完成修复补丁，此时我们发现将hotfix合并回了develop和master分支。</p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-11.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/git-flow-12.png" alt="image"></p></li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">https://nvie.com/posts/a-successful-git-branching-model/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Git 作为源码管理系统，不可避免涉及到多人协作。团队中商定一个工作流程至关重要的。本文已常用的Git flow 做说明，该模型如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nvie.com/img/git-model@2x.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://100067.xyz/categories/Git/"/>
    
    
      <category term="Git" scheme="https://100067.xyz/tags/Git/"/>
    
      <category term="gitflow" scheme="https://100067.xyz/tags/gitflow/"/>
    
  </entry>
  
  <entry>
    <title>斐讯K2 刷机资料</title>
    <link href="https://100067.xyz/2019/12/12/phicomm_k2/"/>
    <id>https://100067.xyz/2019/12/12/phicomm_k2/</id>
    <published>2019-12-12T08:26:50.000Z</published>
    <updated>2019-12-26T08:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><p>K2 : PSG1218</p><h3 id="Breed"><a href="#Breed" class="headerlink" title="Breed"></a>Breed</h3><p> <a href="https://breed.hackpascal.net/" target="_blank" rel="noopener">https://breed.hackpascal.net/</a> </p><h3 id="老毛子padavan"><a href="#老毛子padavan" class="headerlink" title="老毛子padavan"></a>老毛子padavan</h3><p> <a href="https://opt.cn2qq.com/padavan/" target="_blank" rel="noopener">https://opt.cn2qq.com/padavan/</a> </p><a id="more"></a><h4 id="无线AP工作模式"><a href="#无线AP工作模式" class="headerlink" title="无线AP工作模式"></a>无线AP工作模式</h4><ul><li>AP (禁用桥接)</li><li>WDS 桥接 (禁用AP)</li><li>WDS 中继 (桥接 + AP)</li><li>AP-Client (禁用AP)</li><li>AP-Client + AP </li></ul><h4 id="无线AP-Client角色"><a href="#无线AP-Client角色" class="headerlink" title="无线AP-Client角色"></a>无线AP-Client角色</h4><ul><li>LAN bridge :  网桥，简单的说就是承担AP的角色，相当于一个无线交换机了，从主路由获取IP。选择这个就需要关掉华硕的DHCP功能。 </li><li>Wireless ISP :  这个不难理解，就是供应商的形式，副路由在这里就是另外一个网段。选择这个得保证副路由和主路由LAN口地址不在一个网段。 </li></ul><h3 id="高恪"><a href="#高恪" class="headerlink" title="高恪"></a>高恪</h3><p><a href="http://www.gocloud.cn/" target="_blank" rel="noopener">http://www.gocloud.cn/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;型号&quot;&gt;&lt;a href=&quot;#型号&quot; class=&quot;headerlink&quot; title=&quot;型号&quot;&gt;&lt;/a&gt;型号&lt;/h3&gt;&lt;p&gt;K2 : PSG1218&lt;/p&gt;
&lt;h3 id=&quot;Breed&quot;&gt;&lt;a href=&quot;#Breed&quot; class=&quot;headerlink&quot; title=&quot;Breed&quot;&gt;&lt;/a&gt;Breed&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;https://breed.hackpascal.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://breed.hackpascal.net/&lt;/a&gt; &lt;/p&gt;
&lt;h3 id=&quot;老毛子padavan&quot;&gt;&lt;a href=&quot;#老毛子padavan&quot; class=&quot;headerlink&quot; title=&quot;老毛子padavan&quot;&gt;&lt;/a&gt;老毛子padavan&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;https://opt.cn2qq.com/padavan/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://opt.cn2qq.com/padavan/&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="net" scheme="https://100067.xyz/categories/net/"/>
    
    
      <category term="斐讯" scheme="https://100067.xyz/tags/%E6%96%90%E8%AE%AF/"/>
    
      <category term="路由器" scheme="https://100067.xyz/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
      <category term="K2" scheme="https://100067.xyz/tags/K2/"/>
    
      <category term="padavan" scheme="https://100067.xyz/tags/padavan/"/>
    
  </entry>
  
  <entry>
    <title>玩物下载 群晖ARM版 安装方法</title>
    <link href="https://100067.xyz/2019/12/11/synology_owapp_armv8/"/>
    <id>https://100067.xyz/2019/12/11/synology_owapp_armv8/</id>
    <published>2019-12-11T04:00:00.000Z</published>
    <updated>2022-05-02T09:21:18.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="玩物下载-群晖ARM版-安装方法"><a href="#玩物下载-群晖ARM版-安装方法" class="headerlink" title="玩物下载 群晖ARM版 安装方法"></a>玩物下载 群晖ARM版 安装方法</h2><h3 id="玩物下载简介"><a href="#玩物下载简介" class="headerlink" title="玩物下载简介"></a>玩物下载简介</h3><p>玩物下载是一款超轻快且功能强大的下载工具，其下载加速由迅雷提供技术支持。已支持http、BT、电驴、磁力链、迅雷等目前所有主流的下载格式。欢迎您使用玩物下载，希望通过我们的下载技术，能帮助您节约下载时间、减少等待。产品特点：随时随地，想下就下。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本人前些日子入手了猫盘，刷了黑群晖，目前一直稳定使用。可惜猫盘群晖属于ARM平台，比x86平台的群晖少了很多可玩性。看到x86平台上有玩物下载，遂想找下官方有没有提供群晖ARM版本。</p><p>先到<a href="http://www.ionewu.com/pro_wwxz.html" target="_blank" rel="noopener">玩物下载官网</a>看了看，只在帮助中心发现了x86平台spk安装包的下载地址，并没有发现ARM版。</p><p>随后通过Google的帮助，找到了群晖官方spk安装包的下载地址<a href="https://archive.synology.com/download/Package/spk/" target="_blank" rel="noopener">https://archive.synology.com/download/Package/spk/</a>，其中owapp即为玩物下载的文件夹，于是发现官方其实是提供了armv8的spk安装包。</p><p>下载下来发现并不能安装成功，通过7-zip打开安装包看了看，对比了下其他官方套件的安装包，发现INFO文件中的arch的值的问题。群晖官方提供的armv8版套件的安装包中arch的值为<code>armv8</code>，而玩物下载中的值为<code>rtd1296</code>，通过修改后成功安装，于是有了下面的安装方法。</p><p>此文仅仅是记录，无任何技术含量，本首发在了矿渣论坛，后发现被各种博客转载且未注明出处，还不如也在自己博客上发下。</p><a id="more"></a><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><p><a href="https://archive.synology.com/download/Package/spk/owapp/" target="_blank" rel="noopener">https://archive.synology.com/download/Package/spk/owapp/</a></p><p>当前最新版为2.2.12，进入该目录，下载<a href="https://archive.synology.com/download/Package/spk/owapp/2.2.12/owapp-armv8-2.2.12.spk" target="_blank" rel="noopener"> owapp-armv8-2.2.12.spk</a></p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/owapp_armv8_1.png" alt="image"></p><h4 id="提取其中的INFO文件"><a href="#提取其中的INFO文件" class="headerlink" title="提取其中的INFO文件"></a>提取其中的INFO文件</h4><p>使用7-zip打开spk安装包，提取其中的INFO文件</p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/owapp_armv8_2.png" alt="image"></p><h4 id="修改arch值"><a href="#修改arch值" class="headerlink" title="修改arch值"></a>修改arch值</h4><p>将arch的值修改为<code>armv8</code></p><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/owapp_armv8_3.png" alt="image"></p><h4 id="将修改后的INFO文件替换回安装包中"><a href="#将修改后的INFO文件替换回安装包中" class="headerlink" title="将修改后的INFO文件替换回安装包中"></a>将修改后的INFO文件替换回安装包中</h4><h4 id="群晖套件中心手动安装"><a href="#群晖套件中心手动安装" class="headerlink" title="群晖套件中心手动安装"></a>群晖套件中心手动安装</h4><p><img src="https://raw.githubusercontent.com/liuqitoday/image/main/owapp_armv8_4.png" alt="image"></p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>此时玩物下载就安装完成了。如果你懒得自己动手修改的话，我提供下我修改好的安装包供下载。</p><p>2019/12/24：针对<a href="http://www.ionewu.com/pro_wwxz_notice_20191222.html" target="_blank" rel="noopener">卸载问题</a>更新了2.2.13版本的安装包。<a href="https://72k.us/dir/22553047-36210073-05502f" target="_blank" rel="noopener">https://72k.us/dir/22553047-36210073-05502f</a> 提取码：156276</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;玩物下载-群晖ARM版-安装方法&quot;&gt;&lt;a href=&quot;#玩物下载-群晖ARM版-安装方法&quot; class=&quot;headerlink&quot; title=&quot;玩物下载 群晖ARM版 安装方法&quot;&gt;&lt;/a&gt;玩物下载 群晖ARM版 安装方法&lt;/h2&gt;&lt;h3 id=&quot;玩物下载简介&quot;&gt;&lt;a href=&quot;#玩物下载简介&quot; class=&quot;headerlink&quot; title=&quot;玩物下载简介&quot;&gt;&lt;/a&gt;玩物下载简介&lt;/h3&gt;&lt;p&gt;玩物下载是一款超轻快且功能强大的下载工具，其下载加速由迅雷提供技术支持。已支持http、BT、电驴、磁力链、迅雷等目前所有主流的下载格式。欢迎您使用玩物下载，希望通过我们的下载技术，能帮助您节约下载时间、减少等待。产品特点：随时随地，想下就下。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本人前些日子入手了猫盘，刷了黑群晖，目前一直稳定使用。可惜猫盘群晖属于ARM平台，比x86平台的群晖少了很多可玩性。看到x86平台上有玩物下载，遂想找下官方有没有提供群晖ARM版本。&lt;/p&gt;
&lt;p&gt;先到&lt;a href=&quot;http://www.ionewu.com/pro_wwxz.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;玩物下载官网&lt;/a&gt;看了看，只在帮助中心发现了x86平台spk安装包的下载地址，并没有发现ARM版。&lt;/p&gt;
&lt;p&gt;随后通过Google的帮助，找到了群晖官方spk安装包的下载地址&lt;a href=&quot;https://archive.synology.com/download/Package/spk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://archive.synology.com/download/Package/spk/&lt;/a&gt;，其中owapp即为玩物下载的文件夹，于是发现官方其实是提供了armv8的spk安装包。&lt;/p&gt;
&lt;p&gt;下载下来发现并不能安装成功，通过7-zip打开安装包看了看，对比了下其他官方套件的安装包，发现INFO文件中的arch的值的问题。群晖官方提供的armv8版套件的安装包中arch的值为&lt;code&gt;armv8&lt;/code&gt;，而玩物下载中的值为&lt;code&gt;rtd1296&lt;/code&gt;，通过修改后成功安装，于是有了下面的安装方法。&lt;/p&gt;
&lt;p&gt;此文仅仅是记录，无任何技术含量，本首发在了矿渣论坛，后发现被各种博客转载且未注明出处，还不如也在自己博客上发下。&lt;/p&gt;
    
    </summary>
    
      <category term="Synology" scheme="https://100067.xyz/categories/Synology/"/>
    
    
      <category term="Synology" scheme="https://100067.xyz/tags/Synology/"/>
    
      <category term="群晖" scheme="https://100067.xyz/tags/%E7%BE%A4%E6%99%96/"/>
    
      <category term="owapp" scheme="https://100067.xyz/tags/owapp/"/>
    
      <category term="玩物下载" scheme="https://100067.xyz/tags/%E7%8E%A9%E7%89%A9%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>多租户的实现</title>
    <link href="https://100067.xyz/2019/10/09/tenant/"/>
    <id>https://100067.xyz/2019/10/09/tenant/</id>
    <published>2019-10-09T02:20:00.000Z</published>
    <updated>2019-10-12T08:27:51.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="多租户概述"><a href="#多租户概述" class="headerlink" title="多租户概述"></a>多租户概述</h4><p>多租户（Multi Tenancy/Tenant）是一种软件架构，其定义是：在一台服务器上运行单个应用实例，它为多个租户提供服务。</p><h4 id="数据隔离方案"><a href="#数据隔离方案" class="headerlink" title="数据隔离方案"></a>数据隔离方案</h4><ol><li><p>独立数据库</p><p>即一个租户一个数据库。</p></li><li><p>共享数据库，独立Schema</p><p>即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。</p></li><li><p>共享数据库，共享Schema，共享数据表</p><p>即租户共享同一个Database、同一个Schema，但在表中增加租户标识的数据字段。</p></li></ol><a id="more"></a><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>在<code>MySQL</code>没用schema和database的区分，所以上述1、2两种方案大体一致。当前选择最低成本的<code>共享数据库，共享Schema，共享数据表</code>方案。后续讨论全部针对于方案3展开。</p><p>简单来说，意味着每条数据都需要区分出属于哪个租户。为了减少后期开发成本，需要为用户表以及用户相关的表全都增加租户标识的字段（如<code>tenantId</code>）。</p><p>此时涉及与租户相关的<code>SQL</code>都需要拼接<code>tenantId = ?</code>，若手动拼接，改造过程过于繁琐。此时我们想到的方案是根据当前用户所属的租户动态的拼接<code>SQL</code>，恰巧<code>MyBatis-Plus</code>为我们提供了这样功能的插件，仅需要简单的配置即可。</p><h4 id="MyBatis-Plus-的多租户-SQL-解析器配置"><a href="#MyBatis-Plus-的多租户-SQL-解析器配置" class="headerlink" title="MyBatis-Plus 的多租户 SQL 解析器配置"></a>MyBatis-Plus 的多租户 SQL 解析器配置</h4><p>参考官方文档及demo <a href="https://mybatis.plus/guide/tenant.html" target="_blank" rel="noopener">https://mybatis.plus/guide/tenant.html</a></p><p>此处贴一下核心配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&quot;com.liuqitech.demo.dao&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class MyBatisConfig &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 多租户的标识字段</span><br><span class="line">   */</span><br><span class="line">  private static final String TENANT_ID_COLUMN = &quot;TENANT_ID&quot;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 忽略多租户的表名</span><br><span class="line">   */</span><br><span class="line">  private static final List&lt;String&gt; IGNORE_TENANT_TABLES = Lists</span><br><span class="line">      .newArrayList(&quot;table1&quot;, &quot;table2&quot;, &quot;table3&quot;, &quot;table4&quot;);</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public PaginationInterceptor paginationInterceptor() &#123;</span><br><span class="line">    PaginationInterceptor paginationInterceptor = new PaginationInterceptor();</span><br><span class="line">    TenantSqlParser tenantSqlParser = new TenantSqlParser();</span><br><span class="line">    tenantSqlParser.setTenantHandler(new TenantHandler() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public Expression getTenantId(boolean where) &#123;</span><br><span class="line">      // TODO 此处的tenantId需要自己获取当前用户所属的租户</span><br><span class="line">        String tenantId = &quot;liuqitech&quot;;</span><br><span class="line">        return new StringValue(tenantId);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public String getTenantIdColumn() &#123;</span><br><span class="line">        return TENANT_ID_COLUMN;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public boolean doTableFilter(String tableName) &#123;</span><br><span class="line">        return IGNORE_TENANT_TABLES.stream().allMatch(e -&gt; e.equalsIgnoreCase(tableName));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    paginationInterceptor.setSqlParserList(Lists.newArrayList(tenantSqlParser));</span><br><span class="line">    return paginationInterceptor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;多租户概述&quot;&gt;&lt;a href=&quot;#多租户概述&quot; class=&quot;headerlink&quot; title=&quot;多租户概述&quot;&gt;&lt;/a&gt;多租户概述&lt;/h4&gt;&lt;p&gt;多租户（Multi Tenancy/Tenant）是一种软件架构，其定义是：在一台服务器上运行单个应用实例，它为多个租户提供服务。&lt;/p&gt;
&lt;h4 id=&quot;数据隔离方案&quot;&gt;&lt;a href=&quot;#数据隔离方案&quot; class=&quot;headerlink&quot; title=&quot;数据隔离方案&quot;&gt;&lt;/a&gt;数据隔离方案&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;独立数据库&lt;/p&gt;
&lt;p&gt;即一个租户一个数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;共享数据库，独立Schema&lt;/p&gt;
&lt;p&gt;即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;共享数据库，共享Schema，共享数据表&lt;/p&gt;
&lt;p&gt;即租户共享同一个Database、同一个Schema，但在表中增加租户标识的数据字段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://100067.xyz/categories/Java/"/>
    
    
      <category term="MyBatis" scheme="https://100067.xyz/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>JVM笔记 - 运行时内存区域</title>
    <link href="https://100067.xyz/2019/07/04/jvm-spec/"/>
    <id>https://100067.xyz/2019/07/04/jvm-spec/</id>
    <published>2019-07-04T05:26:00.000Z</published>
    <updated>2019-07-05T06:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/dd/JvmSpec7.png" alt="JvmSpec"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>它可以看做是当前线程执行的字节码的指示器。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口信息等。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>它是被所有线程共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例。</p><p>对象的内存布局分为3块区域 对象头、实例数据、对齐填充</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>它也是被所有线程共享的一块区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>运行时常量池是方法区的一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/d/dd/JvmSpec7.png&quot; alt=&quot;JvmSpec&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="Java" scheme="https://100067.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="https://100067.xyz/tags/Java/"/>
    
      <category term="JVM" scheme="https://100067.xyz/tags/JVM/"/>
    
  </entry>
  
</feed>
