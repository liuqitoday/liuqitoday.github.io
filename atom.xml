<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuqitech</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuqitech.com/"/>
  <updated>2019-12-30T01:33:23.474Z</updated>
  <id>https://liuqitech.com/</id>
  
  <author>
    <name>liuqi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git flow 简单入门 | SourceTree操作Git工作流</title>
    <link href="https://liuqitech.com/2019/12/26/git-flow-learn/"/>
    <id>https://liuqitech.com/2019/12/26/git-flow-learn/</id>
    <published>2019-12-26T08:26:50.000Z</published>
    <updated>2019-12-30T01:33:23.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Git 作为源码管理系统，不可避免涉及到多人协作。团队中商定一个工作流程至关重要的。本文已常用的Git flow 做说明，该模型如下图所示：</p><p><img src="https://nvie.com/img/git-model@2x.png" alt="image"></p><a id="more"></a><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>该模型总存在两个长期（核心）分支：</p><ul><li>master</li><li>develop</li></ul><p><code>master</code> ，我们认为该分支存放对外发布的版本，任何时候该分支都是稳定的发布版。我们不可以直接在该分支push 代码。</p><p><code>develop</code> ，我们认为该分支的代码存放的是达到稳定并且准备发布时的，我们的新功能开发都是基于此分支。</p><p>其次，项目存在的三种短期分支：</p><ul><li>feature</li><li>hotfix</li><li>release</li></ul><p><code>feature</code> ，即功能分支，我们进行新功能的开发将在此分支上进行。该分支的代码基于develop 并且最终回合并回develop 分支。</p><p><code>hoxtfix</code> , 即补丁分支，我们进行线上问题修复将在此分支进行，该代码分支基于master 并且最终将合并会develop、master 分支。</p><p> <code>release</code>, 即预发分支。</p><h3 id="操作流程实例"><a href="#操作流程实例" class="headerlink" title="操作流程实例"></a>操作流程实例</h3><p>当我们进行新功能开发时，需要基于develop分支拉取feature分支进行开发，如增加了一个功能 我们将基于develop分支创建 feature/news 分支。</p><p>当功能开发完毕时，我们将提交merge request，将该功能合并到develop 分支。</p><p>当所有feature 功能开发完毕，且都已合并回develop，且开发自己测试完毕后。准备创建预发布版本，就可以基于develop创建release分支。此时测试人员可以基于该版本release进行测试，发现了问题，则需要基于release创建分支，进行修复后，将这些修改合并回release分支同时需要合并回develop分支。</p><p>当具备上线条件时，需要将release分支合并到master和develop分支，然后进行上线操作，线上发布的为master分支。</p><p>当需要修复线上bug时，我们需要基于master创建hotfix分支，当修复且验证完毕后，将hotfix分支合并回master分支，同时为了保证该hotfix包含在下一个发行版中，同时需要合并回develop分支。最后删除hotfix分支。</p><h3 id="SourceTree操作"><a href="#SourceTree操作" class="headerlink" title="SourceTree操作"></a>SourceTree操作</h3><p>SourceTree 的图形化界面git工具，可以简化我们上述的复杂操作。</p><ul><li><p>初始化项目</p><p>点击右上角Git工作流按钮，初始化git flow。</p><p><img src="http://cdn.liuqitech.com/image/git-flow-1.png" alt="image"></p></li><li><p>开发新功能</p><p>点击创建新的功能，此时我们发现已经为我们创建了feature/news分支，我们将在此分支进行功能开发。</p><p><img src="http://cdn.liuqitech.com/image/git-flow-2.png" alt="image"></p><p><img src="http://cdn.liuqitech.com/image/git-flow-3.png" alt="image"></p></li><li><p>开发完成</p><p>点击完成功能。 此时我们发现已经将feature/news分支合并到了develop分支。</p><p><img src="http://cdn.liuqitech.com/image/git-flow-4.png" alt="image"></p></li><li><p>预发布 开始release</p><p>点击建立新的发布版本，此时我们发现已经为我们创建了release/v1.0.0 分支。</p><p><img src="http://cdn.liuqitech.com/image/git-flow-5.png" alt="image"></p><p><img src="http://cdn.liuqitech.com/image/git-flow-6.png" alt="image"></p></li><li><p>发布 完成release</p><p>点击完成发布版本，此时我们发现已经将release/1.0.0分支合并到了develop和master</p><p><img src="http://cdn.liuqitech.com/image/git-flow-7.png" alt="image"></p><p><img src="http://cdn.liuqitech.com/image/git-flow-8.png" alt="image"></p></li><li><p>线上问题修复 开始hotfix</p><p>点击创建新的修复补丁，此时我们发现基于master为我们创建了hotfix/v1.0.0-20191226</p><p><img src="http://cdn.liuqitech.com/image/git-flow-9.png" alt="image"></p><p><img src="http://cdn.liuqitech.com/image/git-flow-10.png" alt="image"></p></li><li><p>完成问题修复 完成hotfix</p><p>点击完成修复补丁，此时我们发现将hotfix合并回了develop和master分支。</p><p><img src="http://cdn.liuqitech.com/image/git-flow-11.png" alt="image"></p><p><img src="http://cdn.liuqitech.com/image/git-flow-12.png" alt="image"></p></li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">https://nvie.com/posts/a-successful-git-branching-model/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Git 作为源码管理系统，不可避免涉及到多人协作。团队中商定一个工作流程至关重要的。本文已常用的Git flow 做说明，该模型如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nvie.com/img/git-model@2x.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://liuqitech.com/categories/Git/"/>
    
    
      <category term="gitflow" scheme="https://liuqitech.com/tags/gitflow/"/>
    
      <category term="Git" scheme="https://liuqitech.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>斐讯K2 刷机资料</title>
    <link href="https://liuqitech.com/2019/12/12/phicomm_k2/"/>
    <id>https://liuqitech.com/2019/12/12/phicomm_k2/</id>
    <published>2019-12-12T08:26:50.000Z</published>
    <updated>2019-12-26T08:16:01.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><p>K2 : PSG1218</p><h3 id="Breed"><a href="#Breed" class="headerlink" title="Breed"></a>Breed</h3><p> <a href="https://breed.hackpascal.net/" target="_blank" rel="noopener">https://breed.hackpascal.net/</a> </p><h3 id="老毛子padavan"><a href="#老毛子padavan" class="headerlink" title="老毛子padavan"></a>老毛子padavan</h3><p> <a href="https://opt.cn2qq.com/padavan/" target="_blank" rel="noopener">https://opt.cn2qq.com/padavan/</a> </p><a id="more"></a><h4 id="无线AP工作模式"><a href="#无线AP工作模式" class="headerlink" title="无线AP工作模式"></a>无线AP工作模式</h4><ul><li>AP (禁用桥接)</li><li>WDS 桥接 (禁用AP)</li><li>WDS 中继 (桥接 + AP)</li><li>AP-Client (禁用AP)</li><li>AP-Client + AP </li></ul><h4 id="无线AP-Client角色"><a href="#无线AP-Client角色" class="headerlink" title="无线AP-Client角色"></a>无线AP-Client角色</h4><ul><li>LAN bridge :  网桥，简单的说就是承担AP的角色，相当于一个无线交换机了，从主路由获取IP。选择这个就需要关掉华硕的DHCP功能。 </li><li>Wireless ISP :  这个不难理解，就是供应商的形式，副路由在这里就是另外一个网段。选择这个得保证副路由和主路由LAN口地址不在一个网段。 </li></ul><h3 id="高恪"><a href="#高恪" class="headerlink" title="高恪"></a>高恪</h3><p><a href="http://www.gocloud.cn/" target="_blank" rel="noopener">http://www.gocloud.cn/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;型号&quot;&gt;&lt;a href=&quot;#型号&quot; class=&quot;headerlink&quot; title=&quot;型号&quot;&gt;&lt;/a&gt;型号&lt;/h3&gt;&lt;p&gt;K2 : PSG1218&lt;/p&gt;
&lt;h3 id=&quot;Breed&quot;&gt;&lt;a href=&quot;#Breed&quot; class=&quot;headerlink&quot; title=&quot;Breed&quot;&gt;&lt;/a&gt;Breed&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;https://breed.hackpascal.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://breed.hackpascal.net/&lt;/a&gt; &lt;/p&gt;
&lt;h3 id=&quot;老毛子padavan&quot;&gt;&lt;a href=&quot;#老毛子padavan&quot; class=&quot;headerlink&quot; title=&quot;老毛子padavan&quot;&gt;&lt;/a&gt;老毛子padavan&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;https://opt.cn2qq.com/padavan/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://opt.cn2qq.com/padavan/&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="net" scheme="https://liuqitech.com/categories/net/"/>
    
    
      <category term="斐讯" scheme="https://liuqitech.com/tags/%E6%96%90%E8%AE%AF/"/>
    
      <category term="路由器" scheme="https://liuqitech.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
      <category term="K2" scheme="https://liuqitech.com/tags/K2/"/>
    
      <category term="padavan" scheme="https://liuqitech.com/tags/padavan/"/>
    
  </entry>
  
  <entry>
    <title>玩物下载 群晖ARM版 安装方法</title>
    <link href="https://liuqitech.com/2019/12/11/synology_owapp_armv8/"/>
    <id>https://liuqitech.com/2019/12/11/synology_owapp_armv8/</id>
    <published>2019-12-11T04:00:00.000Z</published>
    <updated>2020-01-02T05:55:00.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="玩物下载-群晖ARM版-安装方法"><a href="#玩物下载-群晖ARM版-安装方法" class="headerlink" title="玩物下载 群晖ARM版 安装方法"></a>玩物下载 群晖ARM版 安装方法</h2><h3 id="玩物下载简介"><a href="#玩物下载简介" class="headerlink" title="玩物下载简介"></a>玩物下载简介</h3><p>玩物下载是一款超轻快且功能强大的下载工具，其下载加速由迅雷提供技术支持。已支持http、BT、电驴、磁力链、迅雷等目前所有主流的下载格式。欢迎您使用玩物下载，希望通过我们的下载技术，能帮助您节约下载时间、减少等待。产品特点：随时随地，想下就下。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本人前些日子入手了猫盘，刷了黑群晖，目前一直稳定使用。可惜猫盘群晖属于ARM平台，比x86平台的群晖少了很多可玩性。看到x86平台上有玩物下载，遂想找下官方有没有提供群晖ARM版本。</p><p>先到<a href="http://www.ionewu.com/pro_wwxz.html" target="_blank" rel="noopener">玩物下载官网</a>看了看，只在帮助中心发现了x86平台spk安装包的下载地址，并没有发现ARM版。</p><p>随后通过Google的帮助，找到了群晖官方spk安装包的下载地址<a href="https://archive.synology.com/download/Package/spk/" target="_blank" rel="noopener">https://archive.synology.com/download/Package/spk/</a>，其中owapp即为玩物下载的文件夹，于是发现官方其实是提供了armv8的spk安装包。</p><p>下载下来发现并不能安装成功，通过7-zip打开安装包看了看，对比了下其他官方套件的安装包，发现INFO文件中的arch的值的问题。群晖官方提供的armv8版套件的安装包中arch的值为<code>armv8</code>，而玩物下载中的值为<code>rtd1296</code>，通过修改后成功安装，于是有了下面的安装方法。</p><p>此文仅仅是记录，无任何技术含量，本首发在了矿渣论坛，后发现被各种博客转载且未注明出处，还不如也在自己博客上发下。</p><a id="more"></a><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><p><a href="https://archive.synology.com/download/Package/spk/owapp/" target="_blank" rel="noopener">https://archive.synology.com/download/Package/spk/owapp/</a></p><p>当前最新版为2.2.12，进入该目录，下载<a href="https://archive.synology.com/download/Package/spk/owapp/2.2.12/owapp-armv8-2.2.12.spk" target="_blank" rel="noopener"> owapp-armv8-2.2.12.spk</a></p><p><img src="http://cdn.liuqitech.com/image/owapp_armv8_1.png" alt="image"></p><h4 id="提取其中的INFO文件"><a href="#提取其中的INFO文件" class="headerlink" title="提取其中的INFO文件"></a>提取其中的INFO文件</h4><p>使用7-zip打开spk安装包，提取其中的INFO文件</p><p><img src="http://cdn.liuqitech.com/image/owapp_armv8_2.png" alt="image"></p><h4 id="修改arch值"><a href="#修改arch值" class="headerlink" title="修改arch值"></a>修改arch值</h4><p>将arch的值修改为<code>armv8</code></p><p><img src="http://cdn.liuqitech.com/image/owapp_armv8_3.png" alt="image"></p><h4 id="将修改后的INFO文件替换回安装包中"><a href="#将修改后的INFO文件替换回安装包中" class="headerlink" title="将修改后的INFO文件替换回安装包中"></a>将修改后的INFO文件替换回安装包中</h4><h4 id="群晖套件中心手动安装"><a href="#群晖套件中心手动安装" class="headerlink" title="群晖套件中心手动安装"></a>群晖套件中心手动安装</h4><p><img src="http://cdn.liuqitech.com/image/owapp_armv8_4.png" alt="image"></p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>此时玩物下载就安装完成了。如果你懒得自己动手修改的话，我提供下我修改好的安装包供下载。</p><p>2019/12/24：针对<a href="http://www.ionewu.com/pro_wwxz_notice_20191222.html" target="_blank" rel="noopener">卸载问题</a>更新了2.2.13版本的安装包。<a href="https://72k.us/dir/22553047-36210073-05502f" target="_blank" rel="noopener">https://72k.us/dir/22553047-36210073-05502f</a> 提取码：156276</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;玩物下载-群晖ARM版-安装方法&quot;&gt;&lt;a href=&quot;#玩物下载-群晖ARM版-安装方法&quot; class=&quot;headerlink&quot; title=&quot;玩物下载 群晖ARM版 安装方法&quot;&gt;&lt;/a&gt;玩物下载 群晖ARM版 安装方法&lt;/h2&gt;&lt;h3 id=&quot;玩物下载简介&quot;&gt;&lt;a href=&quot;#玩物下载简介&quot; class=&quot;headerlink&quot; title=&quot;玩物下载简介&quot;&gt;&lt;/a&gt;玩物下载简介&lt;/h3&gt;&lt;p&gt;玩物下载是一款超轻快且功能强大的下载工具，其下载加速由迅雷提供技术支持。已支持http、BT、电驴、磁力链、迅雷等目前所有主流的下载格式。欢迎您使用玩物下载，希望通过我们的下载技术，能帮助您节约下载时间、减少等待。产品特点：随时随地，想下就下。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本人前些日子入手了猫盘，刷了黑群晖，目前一直稳定使用。可惜猫盘群晖属于ARM平台，比x86平台的群晖少了很多可玩性。看到x86平台上有玩物下载，遂想找下官方有没有提供群晖ARM版本。&lt;/p&gt;
&lt;p&gt;先到&lt;a href=&quot;http://www.ionewu.com/pro_wwxz.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;玩物下载官网&lt;/a&gt;看了看，只在帮助中心发现了x86平台spk安装包的下载地址，并没有发现ARM版。&lt;/p&gt;
&lt;p&gt;随后通过Google的帮助，找到了群晖官方spk安装包的下载地址&lt;a href=&quot;https://archive.synology.com/download/Package/spk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://archive.synology.com/download/Package/spk/&lt;/a&gt;，其中owapp即为玩物下载的文件夹，于是发现官方其实是提供了armv8的spk安装包。&lt;/p&gt;
&lt;p&gt;下载下来发现并不能安装成功，通过7-zip打开安装包看了看，对比了下其他官方套件的安装包，发现INFO文件中的arch的值的问题。群晖官方提供的armv8版套件的安装包中arch的值为&lt;code&gt;armv8&lt;/code&gt;，而玩物下载中的值为&lt;code&gt;rtd1296&lt;/code&gt;，通过修改后成功安装，于是有了下面的安装方法。&lt;/p&gt;
&lt;p&gt;此文仅仅是记录，无任何技术含量，本首发在了矿渣论坛，后发现被各种博客转载且未注明出处，还不如也在自己博客上发下。&lt;/p&gt;
    
    </summary>
    
      <category term="synology" scheme="https://liuqitech.com/categories/synology/"/>
    
    
      <category term="synology" scheme="https://liuqitech.com/tags/synology/"/>
    
      <category term="owapp" scheme="https://liuqitech.com/tags/owapp/"/>
    
      <category term="玩物下载" scheme="https://liuqitech.com/tags/%E7%8E%A9%E7%89%A9%E4%B8%8B%E8%BD%BD/"/>
    
      <category term="群晖" scheme="https://liuqitech.com/tags/%E7%BE%A4%E6%99%96/"/>
    
  </entry>
  
  <entry>
    <title>多租户的实现</title>
    <link href="https://liuqitech.com/2019/10/09/tenant/"/>
    <id>https://liuqitech.com/2019/10/09/tenant/</id>
    <published>2019-10-09T02:20:00.000Z</published>
    <updated>2019-10-12T08:27:51.996Z</updated>
    
    <content type="html"><![CDATA[<h4 id="多租户概述"><a href="#多租户概述" class="headerlink" title="多租户概述"></a>多租户概述</h4><p>多租户（Multi Tenancy/Tenant）是一种软件架构，其定义是：在一台服务器上运行单个应用实例，它为多个租户提供服务。</p><h4 id="数据隔离方案"><a href="#数据隔离方案" class="headerlink" title="数据隔离方案"></a>数据隔离方案</h4><ol><li><p>独立数据库</p><p>即一个租户一个数据库。</p></li><li><p>共享数据库，独立Schema</p><p>即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。</p></li><li><p>共享数据库，共享Schema，共享数据表</p><p>即租户共享同一个Database、同一个Schema，但在表中增加租户标识的数据字段。</p></li></ol><a id="more"></a><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>在<code>MySQL</code>没用schema和database的区分，所以上述1、2两种方案大体一致。当前选择最低成本的<code>共享数据库，共享Schema，共享数据表</code>方案。后续讨论全部针对于方案3展开。</p><p>简单来说，意味着每条数据都需要区分出属于哪个租户。为了减少后期开发成本，需要为用户表以及用户相关的表全都增加租户标识的字段（如<code>tenantId</code>）。</p><p>此时涉及与租户相关的<code>SQL</code>都需要拼接<code>tenantId = ?</code>，若手动拼接，改造过程过于繁琐。此时我们想到的方案是根据当前用户所属的租户动态的拼接<code>SQL</code>，恰巧<code>MyBatis-Plus</code>为我们提供了这样功能的插件，仅需要简单的配置即可。</p><h4 id="MyBatis-Plus-的多租户-SQL-解析器配置"><a href="#MyBatis-Plus-的多租户-SQL-解析器配置" class="headerlink" title="MyBatis-Plus 的多租户 SQL 解析器配置"></a>MyBatis-Plus 的多租户 SQL 解析器配置</h4><p>参考官方文档及demo <a href="https://mybatis.plus/guide/tenant.html" target="_blank" rel="noopener">https://mybatis.plus/guide/tenant.html</a></p><p>此处贴一下核心配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&quot;com.liuqitech.demo.dao&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class MyBatisConfig &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 多租户的标识字段</span><br><span class="line">   */</span><br><span class="line">  private static final String TENANT_ID_COLUMN = &quot;TENANT_ID&quot;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 忽略多租户的表名</span><br><span class="line">   */</span><br><span class="line">  private static final List&lt;String&gt; IGNORE_TENANT_TABLES = Lists</span><br><span class="line">      .newArrayList(&quot;table1&quot;, &quot;table2&quot;, &quot;table3&quot;, &quot;table4&quot;);</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public PaginationInterceptor paginationInterceptor() &#123;</span><br><span class="line">    PaginationInterceptor paginationInterceptor = new PaginationInterceptor();</span><br><span class="line">    TenantSqlParser tenantSqlParser = new TenantSqlParser();</span><br><span class="line">    tenantSqlParser.setTenantHandler(new TenantHandler() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public Expression getTenantId(boolean where) &#123;</span><br><span class="line">      // TODO 此处的tenantId需要自己获取当前用户所属的租户</span><br><span class="line">        String tenantId = &quot;liuqitech&quot;;</span><br><span class="line">        return new StringValue(tenantId);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public String getTenantIdColumn() &#123;</span><br><span class="line">        return TENANT_ID_COLUMN;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public boolean doTableFilter(String tableName) &#123;</span><br><span class="line">        return IGNORE_TENANT_TABLES.stream().allMatch(e -&gt; e.equalsIgnoreCase(tableName));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    paginationInterceptor.setSqlParserList(Lists.newArrayList(tenantSqlParser));</span><br><span class="line">    return paginationInterceptor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;多租户概述&quot;&gt;&lt;a href=&quot;#多租户概述&quot; class=&quot;headerlink&quot; title=&quot;多租户概述&quot;&gt;&lt;/a&gt;多租户概述&lt;/h4&gt;&lt;p&gt;多租户（Multi Tenancy/Tenant）是一种软件架构，其定义是：在一台服务器上运行单个应用实例，它为多个租户提供服务。&lt;/p&gt;
&lt;h4 id=&quot;数据隔离方案&quot;&gt;&lt;a href=&quot;#数据隔离方案&quot; class=&quot;headerlink&quot; title=&quot;数据隔离方案&quot;&gt;&lt;/a&gt;数据隔离方案&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;独立数据库&lt;/p&gt;
&lt;p&gt;即一个租户一个数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;共享数据库，独立Schema&lt;/p&gt;
&lt;p&gt;即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;共享数据库，共享Schema，共享数据表&lt;/p&gt;
&lt;p&gt;即租户共享同一个Database、同一个Schema，但在表中增加租户标识的数据字段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://liuqitech.com/categories/Java/"/>
    
    
      <category term="MyBatis" scheme="https://liuqitech.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>JVM笔记 - 运行时内存区域</title>
    <link href="https://liuqitech.com/2019/07/04/jvm-spec/"/>
    <id>https://liuqitech.com/2019/07/04/jvm-spec/</id>
    <published>2019-07-04T05:26:00.000Z</published>
    <updated>2019-07-05T06:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/dd/JvmSpec7.png" alt="JvmSpec"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>它可以看做是当前线程执行的字节码的指示器。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口信息等。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>它是被所有线程共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例。</p><p>对象的内存布局分为3块区域 对象头、实例数据、对齐填充</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>它也是被所有线程共享的一块区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>运行时常量池是方法区的一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/d/dd/JvmSpec7.png&quot; alt=&quot;JvmSpec&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="Java" scheme="https://liuqitech.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://liuqitech.com/tags/Java/"/>
    
      <category term="JVM" scheme="https://liuqitech.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础笔记 - 数据类型&amp;部署方式&amp;项目配置</title>
    <link href="https://liuqitech.com/2019/07/02/redis-learn/"/>
    <id>https://liuqitech.com/2019/07/02/redis-learn/</id>
    <published>2019-07-02T09:58:00.000Z</published>
    <updated>2019-07-02T10:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础笔记-数据类型-amp-部署方式-amp-项目配置"><a href="#Redis基础笔记-数据类型-amp-部署方式-amp-项目配置" class="headerlink" title="Redis基础笔记 - 数据类型&amp;部署方式&amp;项目配置"></a>Redis基础笔记 - 数据类型&amp;部署方式&amp;项目配置</h2><h3 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h3><p>Redis 常用的数据类型：strings（字符串）、Lists（列表）、Hashes（哈希）、Sets（集合）、Sorted sets（有序集合） 等。</p><p>官方文档对于数据类型说明 <a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">https://redis.io/topics/data-types-intro</a></p><h4 id="Redis-Strings"><a href="#Redis-Strings" class="headerlink" title="Redis Strings"></a>Redis Strings</h4><p>Redis String 字符串类型，最简单的数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; set mykey somevalue</span><br><span class="line">OK</span><br><span class="line">&gt; get mykey</span><br><span class="line">&quot;somevalue&quot;</span><br></pre></td></tr></table></figure><h4 id="Redis-Lists"><a href="#Redis-Lists" class="headerlink" title="Redis Lists"></a>Redis Lists</h4><p>Redis Lists 存储的字符串类型的元素，是按插入顺序排序的列表。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush mylist A</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush mylist B</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; lpush mylist first</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;first&quot;</span><br><span class="line">2) &quot;A&quot;</span><br><span class="line">3) &quot;B&quot;</span><br><span class="line">&gt; lpop mylist</span><br><span class="line">&quot;first&quot;</span><br><span class="line">&gt; rpop mylist</span><br><span class="line">&quot;B&quot;</span><br><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;A&quot;</span><br></pre></td></tr></table></figure><h4 id="Redis-Hashes"><a href="#Redis-Hashes" class="headerlink" title="Redis Hashes"></a>Redis Hashes</h4><p>Redis Hashes 是字符串类型的键值对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset myhash name liuqi</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; hget myhash name</span><br><span class="line">&quot;liuqi&quot;</span><br><span class="line">&gt; hmset myhash age 27 website liuqitech.com</span><br><span class="line">OK</span><br><span class="line">&gt; hgetall myhash</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;liuqi&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;27&quot;</span><br><span class="line">5) &quot;website&quot;</span><br><span class="line">6) &quot;liuqitech.com&quot;</span><br></pre></td></tr></table></figure><h4 id="Redis-Sets"><a href="#Redis-Sets" class="headerlink" title="Redis Sets"></a>Redis Sets</h4><p>Redis Sets 是字符串类型的无序集合，不能有重复的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd myset 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; smembers myset</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">&gt; sismember myset 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sismember myset 10</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h4 id="Redis-Sorted-sets"><a href="#Redis-Sorted-sets" class="headerlink" title="Redis Sorted sets"></a>Redis Sorted sets</h4><p>Redis Sorted sets 与 Redis Sets 不同的是，每一个元素都会关联一个浮点数类型的分数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd hackers 1940 &quot;Alan Kay&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd hackers 1957 &quot;Sophie Wilson&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd hackers 1953 &quot;Richard Stallman&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd hackers 1949 &quot;Anita Borg&quot;</span><br><span class="line">&gt; zrange hackers 0 -1</span><br><span class="line">1) &quot;Alan Kay&quot;</span><br><span class="line">2) &quot;Anita Borg&quot;</span><br><span class="line">3) &quot;Richard Stallman&quot;</span><br><span class="line">4) &quot;Sophie Wilson&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis-部署方式"><a href="#Redis-部署方式" class="headerlink" title="Redis 部署方式"></a>Redis 部署方式</h3><p>单机、主从、哨兵、集群</p><h4 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h4><p>单机方式没什么好说的，使用默认的配置文件启动即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server redis.conf</span><br></pre></td></tr></table></figure><h4 id="主从复制-（replication）"><a href="#主从复制-（replication）" class="headerlink" title="主从复制 （replication）"></a>主从复制 （replication）</h4><p>配置主从复制方式非常简单，只需要在 slave 的配置文件中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure><p>其中 192.168.1.1 6379 为 master 的IP和端口</p><p>官方文档 <a href="https://redis.io/topics/replication" target="_blank" rel="noopener">https://redis.io/topics/replication</a></p><h4 id="哨兵（Sentinel）"><a href="#哨兵（Sentinel）" class="headerlink" title="哨兵（Sentinel）"></a>哨兵（Sentinel）</h4><p>哨兵是在主从复制的基础上进行的增强方案。原主从复制的方式中，若master宕机，无法进行主从切，所以会引发一些故障。哨兵可以监控多个，master-slave集群，若发现其中的master宕机时，会把该master下的slave转换为master，同时原master下的slave也会slaveof为新的master。</p><p>哨兵启动的方式有以下两种，sentinel的默认端口为26379。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure><p>我们需要配置监听的master，slave无需手动配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">sentinel monitor resque 192.168.1.3 6380 4</span><br><span class="line">sentinel down-after-milliseconds resque 10000</span><br><span class="line">sentinel failover-timeout resque 180000</span><br><span class="line">sentinel parallel-syncs resque 5</span><br></pre></td></tr></table></figure><p>以上为监听两个master的例子。sentinel monitor 语句参数的含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure><p>其中quorum的意义为，当sentinel为集群时，若quorum为2，此时其中监听的一个master发生了宕机，当有2个sentinel认为它为不可用状态的时候才会真正判定该master已经为不可用状态。</p><p>官方文档 <a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">https://redis.io/topics/sentinel</a></p><h4 id="集群-（cluster）"><a href="#集群-（cluster）" class="headerlink" title="集群 （cluster）"></a>集群 （cluster）</h4><p>按照文档做个简单的搭建，复制6份redis到文件夹（如 7000 7001 7002 7003 7004 7005），7000到7005的redis.conf分别按以下模板进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>分别启动这6个reids实例，然后redis-cli创建集群（5以上版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>官方文档 <a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">https://redis.io/topics/cluster-tutorial</a></p><h3 id="Spring-Boot-配置"><a href="#Spring-Boot-配置" class="headerlink" title="Spring Boot 配置"></a>Spring Boot 配置</h3><p>我demo中使用的 Spring Boot 版本为 <code>2.1.6.RELEASE</code></p><p>添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>查看依赖可知现在版本的使用的默认的reids客户端为 <code>Lettuce</code></p><p>通过查看<code>LettuceConnectionConfiguration</code> 可发现，它可以为我们初始化一个 <code>RedisTemplate&lt;Object, Object&gt;</code> 类型的 redisTemplate，和一个 <code>RedisTemplate&lt;String, String&gt;</code> 类型的 stringRedisTemplate。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(RedisOperations.class)</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="line">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br><span class="line">public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)</span><br><span class="line">throws UnknownHostException &#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">return template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)</span><br><span class="line">throws UnknownHostException &#123;</span><br><span class="line">StringRedisTemplate template = new StringRedisTemplate();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">return template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的例子中为了方便测试，直接注入<code>stringRedisTemplate</code> 来使用，当然你也可以自定义自己需要类型的 RedisTemplate。针对不同的部署方式，修改application.yml 配置文件如下：</p><h4 id="单机-1"><a href="#单机-1" class="headerlink" title="单机"></a>单机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    sentinel:</span><br><span class="line">  master: mymaster</span><br><span class="line">  nodes: 127.0.0.1:26379, 127.0.0.1:26380</span><br></pre></td></tr></table></figure><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    cluster:</span><br><span class="line">  nodes: 127.0.0.1:7000, 127.0.0.1:7001, 127.0.0.1:7002, 127.0.0.1:7003, 127.0.0.1:7004, 127.0.0.1:7005</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis基础笔记-数据类型-amp-部署方式-amp-项目配置&quot;&gt;&lt;a href=&quot;#Redis基础笔记-数据类型-amp-部署方式-amp-项目配置&quot; class=&quot;headerlink&quot; title=&quot;Redis基础笔记 - 数据类型&amp;amp;部署方式&amp;amp;项目配置&quot;&gt;&lt;/a&gt;Redis基础笔记 - 数据类型&amp;amp;部署方式&amp;amp;项目配置&lt;/h2&gt;&lt;h3 id=&quot;Redis-数据类型&quot;&gt;&lt;a href=&quot;#Redis-数据类型&quot; class=&quot;headerlink&quot; title=&quot;Redis 数据类型&quot;&gt;&lt;/a&gt;Redis 数据类型&lt;/h3&gt;&lt;p&gt;Redis 常用的数据类型：strings（字符串）、Lists（列表）、Hashes（哈希）、Sets（集合）、Sorted sets（有序集合） 等。&lt;/p&gt;
&lt;p&gt;官方文档对于数据类型说明 &lt;a href=&quot;https://redis.io/topics/data-types-intro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://redis.io/topics/data-types-intro&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Redis-Strings&quot;&gt;&lt;a href=&quot;#Redis-Strings&quot; class=&quot;headerlink&quot; title=&quot;Redis Strings&quot;&gt;&lt;/a&gt;Redis Strings&lt;/h4&gt;&lt;p&gt;Redis String 字符串类型，最简单的数据类型。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; set mykey somevalue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; get mykey&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;somevalue&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;Redis-Lists&quot;&gt;&lt;a href=&quot;#Redis-Lists&quot; class=&quot;headerlink&quot; title=&quot;Redis Lists&quot;&gt;&lt;/a&gt;Redis Lists&lt;/h4&gt;&lt;p&gt;Redis Lists 存储的字符串类型的元素，是按插入顺序排序的列表。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://liuqitech.com/categories/Java/"/>
    
    
      <category term="Redis" scheme="https://liuqitech.com/tags/Redis/"/>
    
      <category term="Java" scheme="https://liuqitech.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>frp 内网穿透</title>
    <link href="https://liuqitech.com/2019/06/16/frp/"/>
    <id>https://liuqitech.com/2019/06/16/frp/</id>
    <published>2019-06-16T08:26:50.000Z</published>
    <updated>2019-12-26T08:14:45.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="frp-内网穿透"><a href="#frp-内网穿透" class="headerlink" title="frp 内网穿透"></a>frp 内网穿透</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于没有公网IP的用户来说，从公网中访问自己的私有设备是一件不太容易的事。</p><p>此时可能我们需要内网穿透，内网穿透的方案有很多，这次我们使用frp来实现。</p><h3 id="frp简介"><a href="#frp简介" class="headerlink" title="frp简介"></a>frp简介</h3><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。</p><p>项目地址：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们需要有一台具有公网IP的机器，正好我手头有一台腾讯云服务器。</p><p>网上也有些个人提供的免费的frp服务端服务，可以用来临时使用。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装非常简单，仅需简单的几个步骤就可以上手。</p><h4 id="服务端-frps"><a href="#服务端-frps" class="headerlink" title="服务端 - frps"></a>服务端 - frps</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载 在github release页面下载适合自己系统的版本</span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.27.0/frp_0.27.0_linux_amd64.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf frp_0.27.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>此时就只剩下配置了，进入frp目录，打开修改 frps.ini 文件，根据自己的需求进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line"># 客户端与服务端token一致才可连接成功</span><br><span class="line">token = 676767 </span><br><span class="line"># dashboard的端口、用户名、密码，启动后可以访问server_ip:port查看对一些信息的监控</span><br><span class="line">dashboard_port = 7500 </span><br><span class="line">dashboard_user = liuqitech</span><br><span class="line">dashboard_pwd = liuqitech</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure><h4 id="客户端-frpc"><a href="#客户端-frpc" class="headerlink" title="客户端 - frpc"></a>客户端 - frpc</h4><p>同样下载frp的包进行解压，打开修改frpc.ini文件，根据自己的需求进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line"># 服务端IP 端口</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line"># token 服务端与客户端需一致</span><br><span class="line">token = 676767</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>以上仅仅是基本配置，还需要根据自己的需求进行不同的配置。</p><p>我本次的目的是实现Windows的远程桌面连接，所以下面的配置文件是按我的需求进行配置的。</p><p>更多不同的配置请参考官方文档<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/fatedier/frp/blob/master/README_zh.md</a></p><p>客户端配置文件 frpc.ini 进行修改，添加以下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[rdp]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line"># 3389为默认的Windows远程桌面连接的端口</span><br><span class="line">local_port = 3389</span><br><span class="line"># 进行远程连接时的端口</span><br><span class="line">remote_port = 7001</span><br></pre></td></tr></table></figure><p>重启客户端使配置文件生效。此时该客户端已经实现了内网穿透。</p><p>当我在另一台Windows电脑进行远程桌面连接时，连接IP写frp服务端IP，端口写上面配置文件中配置的7001时即可连接成功。此时我便可以愉快的在家连接公司的电脑进行办公了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;frp-内网穿透&quot;&gt;&lt;a href=&quot;#frp-内网穿透&quot; class=&quot;headerlink&quot; title=&quot;frp 内网穿透&quot;&gt;&lt;/a&gt;frp 内网穿透&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;对于没有公网IP的用户来说，从公网中访问自己的私有设备是一件不太容易的事。&lt;/p&gt;
&lt;p&gt;此时可能我们需要内网穿透，内网穿透的方案有很多，这次我们使用frp来实现。&lt;/p&gt;
&lt;h3 id=&quot;frp简介&quot;&gt;&lt;a href=&quot;#frp简介&quot; class=&quot;headerlink&quot; title=&quot;frp简介&quot;&gt;&lt;/a&gt;frp简介&lt;/h3&gt;&lt;p&gt;frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/fatedier/frp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/fatedier/frp&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;我们需要有一台具有公网IP的机器，正好我手头有一台腾讯云服务器。&lt;/p&gt;
&lt;p&gt;网上也有些个人提供的免费的frp服务端服务，可以用来临时使用。&lt;/p&gt;
    
    </summary>
    
      <category term="net" scheme="https://liuqitech.com/categories/net/"/>
    
    
      <category term="frp" scheme="https://liuqitech.com/tags/frp/"/>
    
      <category term="内网穿透" scheme="https://liuqitech.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>PushBear试用 - 喝水提醒小助手</title>
    <link href="https://liuqitech.com/2019/06/14/pushbear-demo/"/>
    <id>https://liuqitech.com/2019/06/14/pushbear-demo/</id>
    <published>2019-06-14T08:21:50.000Z</published>
    <updated>2019-06-17T02:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PushBear试用-喝水提醒小助手"><a href="#PushBear试用-喝水提醒小助手" class="headerlink" title="PushBear试用 - 喝水提醒小助手"></a>PushBear试用 - 喝水提醒小助手</h2><h3 id="PushBear简介"><a href="#PushBear简介" class="headerlink" title="PushBear简介"></a>PushBear简介</h3><p>基于微信模板的一对多消息送达服务</p><h3 id="接入说明"><a href="#接入说明" class="headerlink" title="接入说明"></a>接入说明</h3><p>详见官网 <a href="http://pushbear.ftqq.com/" target="_blank" rel="noopener">http://pushbear.ftqq.com</a></p><a id="more"></a><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>废话不多说，直接贴代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> times</span><br><span class="line">times = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remind</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> times</span><br><span class="line">    sendkey = <span class="string">'此处换成自己的'</span></span><br><span class="line">    text = <span class="string">'提醒喝水小助手'</span></span><br><span class="line">    desp = <span class="string">'这是今天第'</span> + str(times) + <span class="string">'次提醒你喝水啦'</span></span><br><span class="line">    payload = &#123;<span class="string">'sendkey'</span>: sendkey, <span class="string">'text'</span>: text, <span class="string">'desp'</span>: desp&#125;</span><br><span class="line">    requests.post(<span class="string">"https://pushbear.ftqq.com/sub"</span>, data=payload)</span><br><span class="line">    times  = times + <span class="number">1</span></span><br><span class="line">    now_hour = datetime.datetime.now().hour</span><br><span class="line">    <span class="keyword">if</span> now_hour &gt;= <span class="number">21</span>:</span><br><span class="line">        times = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    sched = BlockingScheduler()</span><br><span class="line">    sched.add_job(remind, <span class="string">'cron'</span>, hour=<span class="string">'10,11,14,15,16,17,18,21'</span>, minute=<span class="number">6</span>)</span><br><span class="line">    sched.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PushBear试用-喝水提醒小助手&quot;&gt;&lt;a href=&quot;#PushBear试用-喝水提醒小助手&quot; class=&quot;headerlink&quot; title=&quot;PushBear试用 - 喝水提醒小助手&quot;&gt;&lt;/a&gt;PushBear试用 - 喝水提醒小助手&lt;/h2&gt;&lt;h3 id=&quot;PushBear简介&quot;&gt;&lt;a href=&quot;#PushBear简介&quot; class=&quot;headerlink&quot; title=&quot;PushBear简介&quot;&gt;&lt;/a&gt;PushBear简介&lt;/h3&gt;&lt;p&gt;基于微信模板的一对多消息送达服务&lt;/p&gt;
&lt;h3 id=&quot;接入说明&quot;&gt;&lt;a href=&quot;#接入说明&quot; class=&quot;headerlink&quot; title=&quot;接入说明&quot;&gt;&lt;/a&gt;接入说明&lt;/h3&gt;&lt;p&gt;详见官网 &lt;a href=&quot;http://pushbear.ftqq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pushbear.ftqq.com&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WeChat" scheme="https://liuqitech.com/categories/WeChat/"/>
    
    
      <category term="WeChat" scheme="https://liuqitech.com/tags/WeChat/"/>
    
      <category term="Push" scheme="https://liuqitech.com/tags/Push/"/>
    
      <category term="Python" scheme="https://liuqitech.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>jmeter-plugins-dubbo简单试用</title>
    <link href="https://liuqitech.com/2019/02/18/jmeter-plugins-dubbo/"/>
    <id>https://liuqitech.com/2019/02/18/jmeter-plugins-dubbo/</id>
    <published>2019-02-18T04:26:50.000Z</published>
    <updated>2019-12-26T08:15:30.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jmeter-plugins-dubbo简单试用"><a href="#jmeter-plugins-dubbo简单试用" class="headerlink" title="jmeter-plugins-dubbo简单试用"></a>jmeter-plugins-dubbo简单试用</h2><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/dubbo/jmeter-plugins-dubbo" target="_blank" rel="noopener">https://github.com/dubbo/jmeter-plugins-dubbo</a></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载dist目录下的jar包<br>推荐使用 jmeter-plugins-dubbo-${version}-jar-with-dependencies.jar，包含必要的依赖。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>将插件的jar包放入 ${JMETER_HOME}\lib\ext</p><a id="more"></a><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>add -&gt; Sampler -&gt; dubbo sample</p></li><li><p>选择注册中心类型（以zookeeper注册中心为例）</p><p>Protocol -&gt; zookeeper</p></li><li><p>填写注册中心地址</p><p>Address</p></li><li><p>填写Interface与Method</p></li><li><p>填写接口相关参数</p></li></ul><p><img src="http://image.liuqitech.com/blog/jmeter-plugins-dubbo_1.jpg" alt><br><img src="http://image.liuqitech.com/blog/jmeter-plugins-dubbo_2.jpg" alt></p><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://github.com/dubbo/jmeter-plugins-dubbo/wiki/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">https://github.com/dubbo/jmeter-plugins-dubbo/wiki/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97</a></p><p><a href="https://github.com/dubbo/jmeter-plugins-dubbo/wiki/FAQ" target="_blank" rel="noopener">https://github.com/dubbo/jmeter-plugins-dubbo/wiki/FAQ</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;jmeter-plugins-dubbo简单试用&quot;&gt;&lt;a href=&quot;#jmeter-plugins-dubbo简单试用&quot; class=&quot;headerlink&quot; title=&quot;jmeter-plugins-dubbo简单试用&quot;&gt;&lt;/a&gt;jmeter-plugins-dubbo简单试用&lt;/h2&gt;&lt;h3 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dubbo/jmeter-plugins-dubbo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/dubbo/jmeter-plugins-dubbo&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;p&gt;下载dist目录下的jar包&lt;br&gt;推荐使用 jmeter-plugins-dubbo-${version}-jar-with-dependencies.jar，包含必要的依赖。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;将插件的jar包放入 ${JMETER_HOME}\lib\ext&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://liuqitech.com/categories/Java/"/>
    
    
      <category term="JMeter" scheme="https://liuqitech.com/tags/JMeter/"/>
    
      <category term="Dubbo" scheme="https://liuqitech.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Twitter的SnowFlake算法demo</title>
    <link href="https://liuqitech.com/2018/06/10/snowflake/"/>
    <id>https://liuqitech.com/2018/06/10/snowflake/</id>
    <published>2018-06-10T02:10:20.000Z</published>
    <updated>2019-12-26T08:16:23.999Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://i.loli.net/2018/07/23/5b559f07882b1.jpg" alt="image"></p><blockquote><p>41-bit的时间可以表示（1L&lt;&lt;41）/(1000L<em>3600</em>24*365)=69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p></blockquote><a id="more"></a><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class SnowFlakeService &#123;</span><br><span class="line"></span><br><span class="line">    private static final long TIMESTAMP_BIT_NUM = 41L;</span><br><span class="line">    private static final long SEQUENCE_BIT_NUM = 12L;</span><br><span class="line">    private static final long MACHINE_BIT_NUM = 5L;</span><br><span class="line"></span><br><span class="line">    private static final long SEQUENCE_MAX_VALUE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT_NUM);</span><br><span class="line"></span><br><span class="line">    private long BEGIN_TIMESTAMP = 1262275200000L;</span><br><span class="line"></span><br><span class="line">    private long lastTimeStamp = -1L;</span><br><span class="line">    private long sequence = 0L;</span><br><span class="line"></span><br><span class="line">    public Long getSnowFlake(Long machineId) &#123;</span><br><span class="line">        long currentTimeStamp = System.currentTimeMillis();</span><br><span class="line">        if (currentTimeStamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;服务器时间异常！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentTimeStamp == lastTimeStamp) &#123;</span><br><span class="line">            sequence = (sequence + 1) &amp; SEQUENCE_MAX_VALUE;</span><br><span class="line">            if (sequence == 0) &#123;</span><br><span class="line">                currentTimeStamp = getNextTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            lastTimeStamp = currentTimeStamp;</span><br><span class="line">            sequence = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return (currentTimeStamp - BEGIN_TIMESTAMP) &lt;&lt; (MACHINE_BIT_NUM + SEQUENCE_BIT_NUM)</span><br><span class="line">                | machineId &lt;&lt; SEQUENCE_BIT_NUM</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNextTimeMillis() &#123;</span><br><span class="line">        long currentTimeMillis = 0L;</span><br><span class="line">        do &#123;</span><br><span class="line">            currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">        &#125; while (currentTimeMillis &lt;= lastTimeStamp);</span><br><span class="line">        return currentTimeMillis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long beginTime = System.currentTimeMillis();</span><br><span class="line">        SnowFlakeService snowFlakeService = new SnowFlakeService();</span><br><span class="line">        int count = 0;</span><br><span class="line">        while ((System.currentTimeMillis() - beginTime) &lt;= 1000) &#123;</span><br><span class="line">            Long snowFlake = snowFlakeService.getSnowFlake(1L);</span><br><span class="line">            System.out.println(snowFlake);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;产生个数&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/23/5b559f07882b1.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;41-bit的时间可以表示（1L&amp;lt;&amp;lt;41）/(1000L&lt;em&gt;3600&lt;/em&gt;24*365)=69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://liuqitech.com/categories/Java/"/>
    
    
      <category term="snowflake" scheme="https://liuqitech.com/tags/snowflake/"/>
    
      <category term="算法" scheme="https://liuqitech.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="高并发" scheme="https://liuqitech.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>清除微信网页缓存</title>
    <link href="https://liuqitech.com/2018/04/15/clear_wechat_web_cache/"/>
    <id>https://liuqitech.com/2018/04/15/clear_wechat_web_cache/</id>
    <published>2018-04-15T05:26:50.000Z</published>
    <updated>2018-08-21T07:44:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="清除微信网页缓存"><a href="#清除微信网页缓存" class="headerlink" title="清除微信网页缓存"></a>清除微信网页缓存</h2><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><blockquote><p>微信内打开 <a href="http://debugx5.qq.com/" target="_blank" rel="noopener">http://debugx5.qq.com/</a></p></blockquote><h4 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h4><blockquote><p>退出账号，重新登录（并不会删除聊天记录的）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;清除微信网页缓存&quot;&gt;&lt;a href=&quot;#清除微信网页缓存&quot; class=&quot;headerlink&quot; title=&quot;清除微信网页缓存&quot;&gt;&lt;/a&gt;清除微信网页缓存&lt;/h2&gt;&lt;h4 id=&quot;Android&quot;&gt;&lt;a href=&quot;#Android&quot; class=&quot;header
      
    
    </summary>
    
      <category term="WeChat" scheme="https://liuqitech.com/categories/WeChat/"/>
    
    
      <category term="WeChat" scheme="https://liuqitech.com/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>设置HTTP(HTTPS)代理</title>
    <link href="https://liuqitech.com/2018/03/15/http-poxy/"/>
    <id>https://liuqitech.com/2018/03/15/http-poxy/</id>
    <published>2018-03-15T06:51:37.000Z</published>
    <updated>2019-12-26T08:15:19.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>经常会遇到服务器端限制访问速度，常见的是限制IP，这时候我们就需要设置代理IP来解除这种限制。</p><h3 id="设置代理IP（多种实现方式）"><a href="#设置代理IP（多种实现方式）" class="headerlink" title="设置代理IP（多种实现方式）"></a>设置代理IP（多种实现方式）</h3><h4 id="设置系统属性方式"><a href="#设置系统属性方式" class="headerlink" title="设置系统属性方式"></a>设置系统属性方式</h4><p>发送HTTP请求前通过设置JVM中的系统属性来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// HTTP/HTTPS Proxy</span><br><span class="line">System.setProperty(&quot;http.proxyHost&quot;, yourProxyIp);</span><br><span class="line">System.setProperty(&quot;http.proxyPort&quot;, yourProxyProt);</span><br><span class="line">System.setProperty(&quot;https.proxyHost&quot;, yourProxyIp);</span><br><span class="line">System.setProperty(&quot;https.proxyPort&quot;, yourProxyProt);</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="使用HttpClient时设置代理"><a href="#使用HttpClient时设置代理" class="headerlink" title="使用HttpClient时设置代理"></a>使用HttpClient时设置代理</h4><p>直接引用HttpClient官方的示例代码进行说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.http.HttpHost;</span><br><span class="line">import org.apache.http.client.config.RequestConfig;</span><br><span class="line">import org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line">import org.apache.http.client.methods.HttpGet;</span><br><span class="line">import org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line">import org.apache.http.impl.client.HttpClients;</span><br><span class="line">import org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * How to send a request via proxy.</span><br><span class="line"> *</span><br><span class="line"> * @since 4.0</span><br><span class="line"> */</span><br><span class="line">public class ClientExecuteProxy &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)throws Exception &#123;</span><br><span class="line">        CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">        try &#123;</span><br><span class="line">            HttpHost target = new HttpHost(&quot;httpbin.org&quot;, 443, &quot;https&quot;);</span><br><span class="line">            HttpHost proxy = new HttpHost(&quot;127.0.0.1&quot;, 8080, &quot;http&quot;);</span><br><span class="line"></span><br><span class="line">            RequestConfig config = RequestConfig.custom()</span><br><span class="line">                    .setProxy(proxy)</span><br><span class="line">                    .build();</span><br><span class="line">            HttpGet request = new HttpGet(&quot;/&quot;);</span><br><span class="line">            request.setConfig(config);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Executing request &quot; + request.getRequestLine() + &quot; to &quot; + target + &quot; via &quot; + proxy);</span><br><span class="line"></span><br><span class="line">            CloseableHttpResponse response = httpclient.execute(target, request);</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;----------------------------------------&quot;);</span><br><span class="line">                System.out.println(response.getStatusLine());</span><br><span class="line">                System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            httpclient.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;经常会遇到服务器端限制访问速度，常见的是限制IP，这时候我们就需要设置代理IP来解除这种限制。&lt;/p&gt;
&lt;h3 id=&quot;设置代理IP（多种实现方式）&quot;&gt;&lt;a href=&quot;#设置代理IP（多种实现方式）&quot; class=&quot;headerlink&quot; title=&quot;设置代理IP（多种实现方式）&quot;&gt;&lt;/a&gt;设置代理IP（多种实现方式）&lt;/h3&gt;&lt;h4 id=&quot;设置系统属性方式&quot;&gt;&lt;a href=&quot;#设置系统属性方式&quot; class=&quot;headerlink&quot; title=&quot;设置系统属性方式&quot;&gt;&lt;/a&gt;设置系统属性方式&lt;/h4&gt;&lt;p&gt;发送HTTP请求前通过设置JVM中的系统属性来实现&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// HTTP/HTTPS Proxy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.setProperty(&amp;quot;http.proxyHost&amp;quot;, yourProxyIp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.setProperty(&amp;quot;http.proxyPort&amp;quot;, yourProxyProt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.setProperty(&amp;quot;https.proxyHost&amp;quot;, yourProxyIp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.setProperty(&amp;quot;https.proxyPort&amp;quot;, yourProxyProt);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://liuqitech.com/categories/Java/"/>
    
    
      <category term="代理" scheme="https://liuqitech.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中OGNL表达式的强制对象类型</title>
    <link href="https://liuqitech.com/2016/10/16/mybatis-ognl/"/>
    <id>https://liuqitech.com/2016/10/16/mybatis-ognl/</id>
    <published>2016-10-16T06:29:52.000Z</published>
    <updated>2019-12-26T08:15:45.190Z</updated>
    
    <content type="html"><![CDATA[<p>在使用MyBatis过程中可能会遇到如下问题</p><p>mapper.xml中，当type为数字类型并且值为0时，下面的if test判断为false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;if test=&quot;type != null and type != &apos;&apos;&quot;&gt;  </span><br><span class="line">    and type = #&#123;type&#125;   </span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure><p>经过查阅相关资料发现MyBatis中if test的解析是使用的OGNL表达式。</p><a id="more"></a><p>下面贴以下<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">OGNL表达式</a>中关于对象类型强制转换的说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Coercing Objects to Types</span><br><span class="line">Here we describe how OGNL interprets objects as various types. See below for how OGNL coerces objects to booleans, numbers, integers, and collections.</span><br><span class="line"></span><br><span class="line">Interpreting Objects as Booleans</span><br><span class="line">Any object can be used where a boolean is required. OGNL interprets objects as booleans like this:</span><br><span class="line"></span><br><span class="line">If the object is a Boolean, its value is extracted and returned;</span><br><span class="line">If the object is a Number, its double-precision floating-point value is compared with zero; non-zero is treated as true, zero as false;</span><br><span class="line">If the object is a Character, its boolean value is true if and only if its char value is non-zero;</span><br><span class="line">Otherwise, its boolean value is true if and only if it is non-null.</span><br><span class="line">Interpreting Objects as Numbers</span><br><span class="line">Numerical operators try to treat their arguments as numbers. The basic primitive-type wrapper classes (Integer, Double, and so on, including Character and Boolean, which are treated as integers), and the &quot;big&quot; numeric classes from the java.math package (BigInteger and BigDecimal), are recognized as special numeric types. Given an object of some other class, OGNL tries to parse the object&apos;s string value as a number.</span><br><span class="line"></span><br><span class="line">Numerical operators that take two arguments use the following algorithm to decide what type the result should be. The type of the actual result may be wider, if the result does not fit in the given type.</span><br><span class="line"></span><br><span class="line">If both arguments are of the same type, the result will be of the same type if possible;</span><br><span class="line">If either argument is not of a recognized numeric class, it will be treated as if it was a Double for the rest of this algorithm;</span><br><span class="line">If both arguments are approximations to real numbers (Float, Double, or BigDecimal), the result will be the wider type;</span><br><span class="line">If both arguments are integers (Boolean, Byte, Character, Short, Integer, Long, or BigInteger), the result will be the wider type;</span><br><span class="line">If one argument is a real type and the other an integer type, the result will be the real type if the integer is narrower than &quot;int&quot;; BigDecimal if the integer is BigInteger; or the wider of the real type and Double otherwise.</span><br><span class="line">Interpreting Objects as Integers</span><br><span class="line">Operators that work only on integers, like the bit-shifting operators, treat their arguments as numbers, except that BigDecimals and BigIntegers are operated on as BigIntegers and all other kinds of numbers are operated on as Longs. For the BigInteger case, the result of these operators remains a BigInteger; for the Long case, the result is expressed as the same type of the arguments, if it fits, or as a Long otherwise.</span><br><span class="line"></span><br><span class="line">Interpreting Objects as Collections</span><br><span class="line">The projection and selection operators (e1.&#123;e2&#125; and e1.&#123;?e2&#125;), and the in operator, all treat one of their arguments as a collection and walk it. This is done differently depending on the class of the argument:</span><br><span class="line"></span><br><span class="line">Java arrays are walked from front to back;</span><br><span class="line">Members of java.util.Collection are walked by walking their iterators;</span><br><span class="line">Members of java.util.Map are walked by walking iterators over their values;</span><br><span class="line">Members of java.util.Iterator and java.util.Enumeration are walked by iterating them;</span><br><span class="line">Members of java.lang.Number are &quot;walked&quot; by returning integers less than the given number starting with zero;</span><br><span class="line">All other objects are treated as singleton collections containing only themselves.</span><br></pre></td></tr></table></figure><p>那么可以发现上面的判断中type为0时 type != ‘’其实是为false<br>，Number类型的0与空字符串’’进行比较时，0被转换成了空字符串。</p><p>其实规范代码这种问题是不存在的，Number类型是无需和空字符串进行判断的。把该条件去掉只需判断是否为null即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用MyBatis过程中可能会遇到如下问题&lt;/p&gt;
&lt;p&gt;mapper.xml中，当type为数字类型并且值为0时，下面的if test判断为false&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;if test=&amp;quot;type != null and type != &amp;apos;&amp;apos;&amp;quot;&amp;gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    and type = #&amp;#123;type&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/if&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;经过查阅相关资料发现MyBatis中if test的解析是使用的OGNL表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://liuqitech.com/categories/Java/"/>
    
    
      <category term="OGNL" scheme="https://liuqitech.com/tags/OGNL/"/>
    
      <category term="MyBatis" scheme="https://liuqitech.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Windows + Ubuntu双系统删除Ubuntu</title>
    <link href="https://liuqitech.com/2016/03/15/delete-ubuntu/"/>
    <id>https://liuqitech.com/2016/03/15/delete-ubuntu/</id>
    <published>2016-03-15T09:48:30.000Z</published>
    <updated>2019-04-28T10:20:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="确定启动方式-UEFI、Legacy"><a href="#确定启动方式-UEFI、Legacy" class="headerlink" title="确定启动方式(UEFI、Legacy)"></a>确定启动方式(UEFI、Legacy)</h3><p>按 WIN+R 快捷键打开“运行”，输入 msinfo32 确定打开“系统信息”，在系统摘要中即可看到BIOS模式。<br><img src="http://image.liuqitech.com/blog/systeminfo.png" alt="image"></p><a id="more"></a><h3 id="UEFI-方式的操作"><a href="#UEFI-方式的操作" class="headerlink" title="UEFI 方式的操作"></a>UEFI 方式的操作</h3><p>借助<a href="https://www.easyuefi.com/index-us.html" target="_blank" rel="noopener">EasyUEFI</a>来实现，下载安装运行软件，点击“管理EFI”启动项，删除Ubuntu项即可。<br><img src="http://image.liuqitech.com/blog/EasyUEFI.png" alt="image"></p><h3 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h3><p>管理计算机-磁盘管理<br>找到Ubuntu对应的分区，删除卷即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;确定启动方式-UEFI、Legacy&quot;&gt;&lt;a href=&quot;#确定启动方式-UEFI、Legacy&quot; class=&quot;headerlink&quot; title=&quot;确定启动方式(UEFI、Legacy)&quot;&gt;&lt;/a&gt;确定启动方式(UEFI、Legacy)&lt;/h3&gt;&lt;p&gt;按 WIN+R 快捷键打开“运行”，输入 msinfo32 确定打开“系统信息”，在系统摘要中即可看到BIOS模式。&lt;br&gt;&lt;img src=&quot;http://image.liuqitech.com/blog/systeminfo.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="https://liuqitech.com/categories/Windows/"/>
    
    
      <category term="双系统" scheme="https://liuqitech.com/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
