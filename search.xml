<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多租户的实现]]></title>
    <url>%2F2019%2F10%2F09%2Ftenant%2F</url>
    <content type="text"><![CDATA[多租户概述多租户（Multi Tenancy/Tenant）是一种软件架构，其定义是：在一台服务器上运行单个应用实例，它为多个租户提供服务。 数据隔离方案 独立数据库 即一个租户一个数据库。 共享数据库，独立Schema 即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。 共享数据库，共享Schema，共享数据表 即租户共享同一个Database、同一个Schema，但在表中增加租户标识的数据字段。 实现方式在MySQL没用schema和database的区分，所以上述1、2两种方案大体一致。当前选择最低成本的共享数据库，共享Schema，共享数据表方案。后续讨论全部针对于方案3展开。 简单来说，意味着每条数据都需要区分出属于哪个租户。为了减少后期开发成本，需要为用户表以及用户相关的表全都增加租户标识的字段（如tenantId）。 此时涉及与租户相关的SQL都需要在where条件中拼接tenantId = ?，若手动拼接，改造过程过于繁琐。此时我们想到的方案是根据当前用户所属的租户动态的拼接SQL，恰巧MyBatis-Plus为我们提供了这样功能的插件，仅需要简单的配置即可。 另外涉及数据写入的逻辑里，增加多租户的处理。 MyBatis-Plus 的多租户 SQL 解析器配置参考官方文档及demo https://mybatis.plus/guide/tenant.html 此处贴一下核心配置 123456789101112131415161718192021222324252627282930313233343536373839404142@MapperScan(&quot;com.liuqitech.demo.dao&quot;)@Configurationpublic class MyBatisConfig &#123; /** * 多租户的标识字段 */ private static final String TENANT_ID_COLUMN = &quot;TENANT_ID&quot;; /** * 忽略多租户的表名 */ private static final List&lt;String&gt; IGNORE_TENANT_TABLES = Lists .newArrayList(&quot;table1&quot;, &quot;table2&quot;, &quot;table3&quot;, &quot;table4&quot;); @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); TenantSqlParser tenantSqlParser = new TenantSqlParser(); tenantSqlParser.setTenantHandler(new TenantHandler() &#123; @Override public Expression getTenantId(boolean where) &#123; // TODO 此处的tenantId需要自己获取当前用户所属的租户 String tenantId = &quot;liuqitech&quot;; return new StringValue(tenantId); &#125; @Override public String getTenantIdColumn() &#123; return TENANT_ID_COLUMN; &#125; @Override public boolean doTableFilter(String tableName) &#123; return IGNORE_TENANT_TABLES.stream().allMatch(e -&gt; e.equalsIgnoreCase(tableName)); &#125; &#125;); paginationInterceptor.setSqlParserList(Lists.newArrayList(tenantSqlParser)); return paginationInterceptor; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM笔记 - 运行时内存区域]]></title>
    <url>%2F2019%2F07%2F04%2Fjvm-spec%2F</url>
    <content type="text"><![CDATA[程序计数器它可以看做是当前线程执行的字节码的指示器。 Java虚拟机栈它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口信息等。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 本地方法栈Java堆它是被所有线程共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例。 对象的内存布局分为3块区域 对象头、实例数据、对齐填充 方法区它也是被所有线程共享的一块区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池是方法区的一部分。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础笔记 - 数据类型&部署方式&项目配置]]></title>
    <url>%2F2019%2F07%2F02%2Fredis-learn%2F</url>
    <content type="text"><![CDATA[Redis基础笔记 - 数据类型&amp;部署方式&amp;项目配置Redis 数据类型Redis 常用的数据类型：strings（字符串）、Lists（列表）、Hashes（哈希）、Sets（集合）、Sorted sets（有序集合） 等。 官方文档对于数据类型说明 https://redis.io/topics/data-types-intro Redis StringsRedis String 字符串类型，最简单的数据类型。 1234&gt; set mykey somevalueOK&gt; get mykey&quot;somevalue&quot; Redis ListsRedis Lists 存储的字符串类型的元素，是按插入顺序排序的列表。 12345678910111213141516&gt; rpush mylist A(integer) 1&gt; rpush mylist B(integer) 2&gt; lpush mylist first(integer) 3&gt; lrange mylist 0 -11) &quot;first&quot;2) &quot;A&quot;3) &quot;B&quot;&gt; lpop mylist&quot;first&quot;&gt; rpop mylist&quot;B&quot;&gt; lrange mylist 0 -11) &quot;A&quot; Redis HashesRedis Hashes 是字符串类型的键值对。 12345678910111213&gt; hset myhash name liuqi(integer) 0&gt; hget myhash name&quot;liuqi&quot;&gt; hmset myhash age 27 website liuqitech.comOK&gt; hgetall myhash1) &quot;name&quot;2) &quot;liuqi&quot;3) &quot;age&quot;4) &quot;27&quot;5) &quot;website&quot;6) &quot;liuqitech.com&quot; Redis SetsRedis Sets 是字符串类型的无序集合，不能有重复的元素。 12345678910&gt; sadd myset 1 2 3(integer) 3&gt; smembers myset1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;&gt; sismember myset 1(integer) 1&gt; sismember myset 10(integer) 0 Redis Sorted setsRedis Sorted sets 与 Redis Sets 不同的是，每一个元素都会关联一个浮点数类型的分数。 123456789101112&gt; zadd hackers 1940 &quot;Alan Kay&quot;(integer) 1&gt; zadd hackers 1957 &quot;Sophie Wilson&quot;(integer) 1&gt; zadd hackers 1953 &quot;Richard Stallman&quot;(integer) 1&gt; zadd hackers 1949 &quot;Anita Borg&quot;&gt; zrange hackers 0 -11) &quot;Alan Kay&quot;2) &quot;Anita Borg&quot;3) &quot;Richard Stallman&quot;4) &quot;Sophie Wilson&quot; Redis 部署方式单机、主从、哨兵、集群 单机单机方式没什么好说的，使用默认的配置文件启动即可。 1./redis-server redis.conf 主从复制 （replication）配置主从复制方式非常简单，只需要在 slave 的配置文件中添加如下配置： 1slaveof 192.168.1.1 6379 其中 192.168.1.1 6379 为 master 的IP和端口 官方文档 https://redis.io/topics/replication 哨兵（Sentinel）哨兵是在主从复制的基础上进行的增强方案。原主从复制的方式中，若master宕机，无法进行主从切，所以会引发一些故障。哨兵可以监控多个，master-slave集群，若发现其中的master宕机时，会把该master下的slave转换为master，同时原master下的slave也会slaveof为新的master。 哨兵启动的方式有以下两种，sentinel的默认端口为26379。 1redis-sentinel /path/to/sentinel.conf 1redis-server /path/to/sentinel.conf --sentinel 我们需要配置监听的master，slave无需手动配置。 123456789sentinel monitor mymaster 127.0.0.1 6379 2sentinel down-after-milliseconds mymaster 60000sentinel failover-timeout mymaster 180000sentinel parallel-syncs mymaster 1sentinel monitor resque 192.168.1.3 6380 4sentinel down-after-milliseconds resque 10000sentinel failover-timeout resque 180000sentinel parallel-syncs resque 5 以上为监听两个master的例子。sentinel monitor 语句参数的含义如下： 1sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt; 其中quorum的意义为，当sentinel为集群时，若quorum为2，此时其中监听的一个master发生了宕机，当有2个sentinel认为它为不可用状态的时候才会真正判定该master已经为不可用状态。 官方文档 https://redis.io/topics/sentinel 集群 （cluster）按照文档做个简单的搭建，复制6份redis到文件夹（如 7000 7001 7002 7003 7004 7005），7000到7005的redis.conf分别按以下模板进行配置 12345port 7000cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yes 分别启动这6个reids实例，然后redis-cli创建集群（5以上版本） 1./redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1 官方文档 https://redis.io/topics/cluster-tutorial Spring Boot 配置我demo中使用的 Spring Boot 版本为 2.1.6.RELEASE 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 查看依赖可知现在版本的使用的默认的reids客户端为 Lettuce 通过查看LettuceConnectionConfiguration 可发现，它可以为我们初始化一个 RedisTemplate&lt;Object, Object&gt; 类型的 redisTemplate，和一个 RedisTemplate&lt;String, String&gt; 类型的 stringRedisTemplate。 12345678910111213141516171819202122232425@Configuration@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)public class RedisAutoConfiguration &#123; @Bean @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; 后面的例子中为了方便测试，直接注入stringRedisTemplate 来使用，当然你也可以自定义自己需要类型的 RedisTemplate。针对不同的部署方式，修改application.yml 配置文件如下： 单机1234spring: redis: host: 127.0.0.1 port: 6379 哨兵12345spring: redis: sentinel: master: mymaster nodes: 127.0.0.1:26379, 127.0.0.1:26380 集群1234spring: redis: cluster: nodes: 127.0.0.1:7000, 127.0.0.1:7001, 127.0.0.1:7002, 127.0.0.1:7003, 127.0.0.1:7004, 127.0.0.1:7005]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp 内网穿透]]></title>
    <url>%2F2019%2F06%2F16%2Ffrp%2F</url>
    <content type="text"><![CDATA[frp 内网穿透前言对于没有公网IP的用户来说，从公网中访问自己的私有设备是一件不太容易的事。 此时可能我们需要内网穿透，内网穿透的方案有很多，这次我们使用frp来实现。 frp简介frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。 项目地址：https://github.com/fatedier/frp 准备工作我们需要有一台具有公网IP的机器，正好我手头有一台腾讯云服务器。 网上也有些个人提供的免费的frp服务端服务，可以用来临时使用。 安装安装非常简单，仅需简单的几个步骤就可以上手。 服务端 - frps1234# 下载 在github release页面下载适合自己系统的版本wget https://github.com/fatedier/frp/releases/download/v0.27.0/frp_0.27.0_linux_amd64.tar.gz# 解压tar -zxvf frp_0.27.0_linux_amd64.tar.gz 此时就只剩下配置了，进入frp目录，打开修改 frps.ini 文件，根据自己的需求进行配置。 12345678[common]bind_port = 7000# 客户端与服务端token一致才可连接成功token = 676767 # dashboard的端口、用户名、密码，启动后可以访问server_ip:port查看对一些信息的监控dashboard_port = 7500 dashboard_user = liuqitechdashboard_pwd = liuqitech 启动 1./frps -c frps.ini 客户端 - frpc同样下载frp的包进行解压，打开修改frpc.ini文件，根据自己的需求进行配置 123456[common]# 服务端IP 端口server_addr = x.x.x.xserver_port = 7000# token 服务端与客户端需一致token = 676767 启动 1./frpc.exe -c frpc.ini 使用实例以上仅仅是基本配置，还需要根据自己的需求进行不同的配置。 我本次的目的是实现Windows的远程桌面连接，所以下面的配置文件是按我的需求进行配置的。 更多不同的配置请参考官方文档https://github.com/fatedier/frp/blob/master/README_zh.md 客户端配置文件 frpc.ini 进行修改，添加以下配置 1234567[rdp]type = tcplocal_ip = 127.0.0.1# 3389为默认的Windows远程桌面连接的端口local_port = 3389# 进行远程连接时的端口remote_port = 7001 重启客户端使配置文件生效。此时该客户端已经实现了内网穿透。 当我在另一台Windows电脑进行远程桌面连接时，连接IP写frp服务端IP，端口写上面配置文件中配置的7001时即可连接成功。此时我便可以愉快的在家连接公司的电脑进行办公了。]]></content>
      <categories>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PushBear试用 - 喝水提醒小助手]]></title>
    <url>%2F2019%2F06%2F14%2Fpushbear-demo%2F</url>
    <content type="text"><![CDATA[PushBear试用 - 喝水提醒小助手PushBear简介基于微信模板的一对多消息送达服务 接入说明详见官网 http://pushbear.ftqq.com DEMO废话不多说，直接贴代码 1234567891011121314151617181920212223import requestsimport datetimefrom apscheduler.schedulers.blocking import BlockingSchedulerglobal timestimes = 1def remind(): global times sendkey = '此处换成自己的' text = '提醒喝水小助手' desp = '这是今天第' + str(times) + '次提醒你喝水啦' payload = &#123;'sendkey': sendkey, 'text': text, 'desp': desp&#125; requests.post("https://pushbear.ftqq.com/sub", data=payload) times = times + 1 now_hour = datetime.datetime.now().hour if now_hour &gt;= 21: times = 1if __name__ == "__main__": sched = BlockingScheduler() sched.add_job(remind, 'cron', hour='10,11,14,15,16,17,18,21', minute=6) sched.start()]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
        <tag>Push</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jmeter-plugins-dubbo简单试用]]></title>
    <url>%2F2019%2F02%2F18%2Fjmeter-plugins-dubbo%2F</url>
    <content type="text"><![CDATA[jmeter-plugins-dubbo简单试用项目地址https://github.com/dubbo/jmeter-plugins-dubbo 下载下载dist目录下的jar包推荐使用 jmeter-plugins-dubbo-${version}-jar-with-dependencies.jar，包含必要的依赖。 安装将插件的jar包放入 ${JMETER_HOME}\lib\ext 使用 add -&gt; Sampler -&gt; dubbo sample 选择注册中心类型（以zookeeper注册中心为例） Protocol -&gt; zookeeper 填写注册中心地址 Address 填写Interface与Method 填写接口相关参数 官方文档https://github.com/dubbo/jmeter-plugins-dubbo/wiki/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97 https://github.com/dubbo/jmeter-plugins-dubbo/wiki/FAQ]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Twitter的SnowFlake算法demo]]></title>
    <url>%2F2018%2F06%2F10%2Fsnowflake%2F</url>
    <content type="text"><![CDATA[概述 41-bit的时间可以表示（1L&lt;&lt;41）/(1000L360024*365)=69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SnowFlakeService &#123; private static final long TIMESTAMP_BIT_NUM = 41L; private static final long SEQUENCE_BIT_NUM = 12L; private static final long MACHINE_BIT_NUM = 5L; private static final long SEQUENCE_MAX_VALUE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT_NUM); private long BEGIN_TIMESTAMP = 1262275200000L; private long lastTimeStamp = -1L; private long sequence = 0L; public Long getSnowFlake(Long machineId) &#123; long currentTimeStamp = System.currentTimeMillis(); if (currentTimeStamp &lt; lastTimeStamp) &#123; throw new RuntimeException(&quot;服务器时间异常！&quot;); &#125; if (currentTimeStamp == lastTimeStamp) &#123; sequence = (sequence + 1) &amp; SEQUENCE_MAX_VALUE; if (sequence == 0) &#123; currentTimeStamp = getNextTimeMillis(); &#125; &#125; else &#123; lastTimeStamp = currentTimeStamp; sequence = 0; &#125; return (currentTimeStamp - BEGIN_TIMESTAMP) &lt;&lt; (MACHINE_BIT_NUM + SEQUENCE_BIT_NUM) | machineId &lt;&lt; SEQUENCE_BIT_NUM | sequence; &#125; private long getNextTimeMillis() &#123; long currentTimeMillis = 0L; do &#123; currentTimeMillis = System.currentTimeMillis(); &#125; while (currentTimeMillis &lt;= lastTimeStamp); return currentTimeMillis; &#125; public static void main(String[] args) &#123; long beginTime = System.currentTimeMillis(); SnowFlakeService snowFlakeService = new SnowFlakeService(); int count = 0; while ((System.currentTimeMillis() - beginTime) &lt;= 1000) &#123; Long snowFlake = snowFlakeService.getSnowFlake(1L); System.out.println(snowFlake); count++; &#125; System.out.println(&quot;产生个数&quot; + count); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>snowflake</tag>
        <tag>算法</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除微信网页缓存]]></title>
    <url>%2F2018%2F04%2F15%2Fclear_wechat_web_cache%2F</url>
    <content type="text"><![CDATA[清除微信网页缓存Android 微信内打开 http://debugx5.qq.com/ IOS 退出账号，重新登录（并不会删除聊天记录的）。]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置HTTP(HTTPS)代理]]></title>
    <url>%2F2018%2F03%2F15%2Fhttp-poxy%2F</url>
    <content type="text"><![CDATA[背景经常会遇到服务器端限制访问速度，常见的是限制IP，这时候我们就需要设置代理IP来解除这种限制。 设置代理IP（多种实现方式）设置系统属性方式发送HTTP请求前通过设置JVM中的系统属性来实现 12345// HTTP/HTTPS ProxySystem.setProperty(&quot;http.proxyHost&quot;, yourProxyIp);System.setProperty(&quot;http.proxyPort&quot;, yourProxyProt);System.setProperty(&quot;https.proxyHost&quot;, yourProxyIp);System.setProperty(&quot;https.proxyPort&quot;, yourProxyProt); 使用HttpClient时设置代理直接引用HttpClient官方的示例代码进行说明 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.http.HttpHost;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;/** * How to send a request via proxy. * * @since 4.0 */public class ClientExecuteProxy &#123; public static void main(String[] args)throws Exception &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; HttpHost target = new HttpHost(&quot;httpbin.org&quot;, 443, &quot;https&quot;); HttpHost proxy = new HttpHost(&quot;127.0.0.1&quot;, 8080, &quot;http&quot;); RequestConfig config = RequestConfig.custom() .setProxy(proxy) .build(); HttpGet request = new HttpGet(&quot;/&quot;); request.setConfig(config); System.out.println(&quot;Executing request &quot; + request.getRequestLine() + &quot; to &quot; + target + &quot; via &quot; + proxy); CloseableHttpResponse response = httpclient.execute(target, request); try &#123; System.out.println(&quot;----------------------------------------&quot;); System.out.println(response.getStatusLine()); System.out.println(EntityUtils.toString(response.getEntity())); &#125; finally &#123; response.close(); &#125; &#125; finally &#123; httpclient.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis中OGNL表达式的强制对象类型]]></title>
    <url>%2F2016%2F10%2F16%2Fmybatis-ognl%2F</url>
    <content type="text"><![CDATA[在使用MyBatis过程中可能会遇到如下问题 mapper.xml中，当type为数字类型并且值为0时，下面的if test判断为false 123&lt;if test=&quot;type != null and type != &apos;&apos;&quot;&gt; and type = #&#123;type&#125; &lt;/if&gt; 经过查阅相关资料发现MyBatis中if test的解析是使用的OGNL表达式。 下面贴以下OGNL表达式中关于对象类型强制转换的说明 1234567891011121314151617181920212223242526272829303132Coercing Objects to TypesHere we describe how OGNL interprets objects as various types. See below for how OGNL coerces objects to booleans, numbers, integers, and collections.Interpreting Objects as BooleansAny object can be used where a boolean is required. OGNL interprets objects as booleans like this:If the object is a Boolean, its value is extracted and returned;If the object is a Number, its double-precision floating-point value is compared with zero; non-zero is treated as true, zero as false;If the object is a Character, its boolean value is true if and only if its char value is non-zero;Otherwise, its boolean value is true if and only if it is non-null.Interpreting Objects as NumbersNumerical operators try to treat their arguments as numbers. The basic primitive-type wrapper classes (Integer, Double, and so on, including Character and Boolean, which are treated as integers), and the &quot;big&quot; numeric classes from the java.math package (BigInteger and BigDecimal), are recognized as special numeric types. Given an object of some other class, OGNL tries to parse the object&apos;s string value as a number.Numerical operators that take two arguments use the following algorithm to decide what type the result should be. The type of the actual result may be wider, if the result does not fit in the given type.If both arguments are of the same type, the result will be of the same type if possible;If either argument is not of a recognized numeric class, it will be treated as if it was a Double for the rest of this algorithm;If both arguments are approximations to real numbers (Float, Double, or BigDecimal), the result will be the wider type;If both arguments are integers (Boolean, Byte, Character, Short, Integer, Long, or BigInteger), the result will be the wider type;If one argument is a real type and the other an integer type, the result will be the real type if the integer is narrower than &quot;int&quot;; BigDecimal if the integer is BigInteger; or the wider of the real type and Double otherwise.Interpreting Objects as IntegersOperators that work only on integers, like the bit-shifting operators, treat their arguments as numbers, except that BigDecimals and BigIntegers are operated on as BigIntegers and all other kinds of numbers are operated on as Longs. For the BigInteger case, the result of these operators remains a BigInteger; for the Long case, the result is expressed as the same type of the arguments, if it fits, or as a Long otherwise.Interpreting Objects as CollectionsThe projection and selection operators (e1.&#123;e2&#125; and e1.&#123;?e2&#125;), and the in operator, all treat one of their arguments as a collection and walk it. This is done differently depending on the class of the argument:Java arrays are walked from front to back;Members of java.util.Collection are walked by walking their iterators;Members of java.util.Map are walked by walking iterators over their values;Members of java.util.Iterator and java.util.Enumeration are walked by iterating them;Members of java.lang.Number are &quot;walked&quot; by returning integers less than the given number starting with zero;All other objects are treated as singleton collections containing only themselves. 那么可以发现上面的判断中type为0时 type != ‘’其实是为false，Number类型的0与空字符串’’进行比较时，0被转换成了空字符串。 其实规范代码这种问题是不存在的，Number类型是无需和空字符串进行判断的。把该条件去掉只需判断是否为null即可。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>OGNL</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows + Ubuntu双系统删除Ubuntu]]></title>
    <url>%2F2016%2F03%2F15%2Fdelete-ubuntu%2F</url>
    <content type="text"><![CDATA[确定启动方式(UEFI、Legacy)按 WIN+R 快捷键打开“运行”，输入 msinfo32 确定打开“系统信息”，在系统摘要中即可看到BIOS模式。 UEFI 方式的操作借助EasyUEFI来实现，下载安装运行软件，点击“管理EFI”启动项，删除Ubuntu项即可。 删除分区管理计算机-磁盘管理找到Ubuntu对应的分区，删除卷即可。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>双系统</tag>
      </tags>
  </entry>
</search>
